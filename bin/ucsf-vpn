#!/usr/bin/env bash
### Connect to and Disconnect from the UCSF VPN
###
### Usage:
###  ucsf-vpn <command> [options]
###
### Commands:
###  start-gui        Open the Pulse Secure GUI
###  start            Connects to UCSF VPN
###  stop             Disconnects from UCSF VPN
###  restart          Disconnects and reconnects to UCSF VPN
###  toggle           Connects to or disconnects from UCSF VPN
###  status           Displays UCSF VPN connection status
###  details          Displays connection details
###  log              Displays the log file
###  troubleshoot     Scan the log file for errors
###
### Options:
###  --user <user>    UCSF Active Directory ID (username)
###  --pwd <pwd>      UCSF Active Directory ID password
###  --server <host>  VPN server (defaults to remote.ucsf.edu)
###  --realm <realm>  VPN server (defaults to 'Single-Factor Pulse Clients')
###  --skip           If already fulfilled, skip command
###  --force          Force running the command
###  --verbose        Verbose output
###  --help           This help
###  --version        Display version
###
### Any other options are passed to Pulse Secure as is.
###
### Example:
###  ucsf-vpn start --user alice --pwd secrets
###  ucsf-vpn stop
###
### User credentials:
### If --user and/or --pwd are not specified, then the user will be
### prompted to enter them.  Furthermore, the default values for --user
### and --pwd can be specified in your ~/.netrc file (or according to
### environment variable NETRC).  For example:
###
###   machine remote.ucsf.edu
###       login alice
###       password secrets
###
### For security, the ~/.netrc file should be readable only by
### the user / owner of the file.  If not, then 'ucsf-vpn start' will
### set its permission accordingly (by calling chmod go-rwx ~/.netrc).
###
### Requirements:
### * Junos Pulse Secure client (>= 5.3) (installed: {{pulsesvc_version}})
### * Ports 4242 (UDP) and 443 (TCP)
### * `curl`
### * No need for sudo rights to run :)
###
### Troubleshooting:
### * Verify your username and password at https://remote.ucsf.edu/.
###   This should be your UCSF Active Directory ID (username); neither
###   MyAccess SFID (e.g. 'sf*****') nor UCSF email address will work.
### * Make sure ports 4242 & 443 are not used by other processes
### * If you are using the Pulse Secure GUI (`ucsf-vpn start-gui`), use
###   'https://remote.ucsf.edu/pulse' as the URL when adding a new
###   connection.
### * The Pulse Secure log is at $HOME/.pulse_secure/pulse/pulsesvc.log.
###
### Useful resources:
### * UCSF VPN information:
###   - https://software.ucsf.edu/content/vpn-virtual-private-network
### * UCSF Web-based VPN Interface:
###   - https://remote.ucsf.edu/
### * UCSF Two-Factory Authentication (2FA):
###   - https://it.ucsf.edu/services/duo-two-factor-authentication
### * UCSF Active Directory Account Manager:
###   - https://pwmanage.ucsf.edu/pm/
###
### Version: 2.3.0-9000
### Copyright: Henrik Bengtsson (2016-2017)
### License: GPL (>= 2.1) [https://www.gnu.org/licenses/gpl.html]
### Source: https://github.com/HenrikBengtsson/ucsf-vpn
call="$0 $*"

export PULSEDIR=/usr/local/pulse
export PATH="${PULSEDIR}:${PATH}"
export LD_LIBRARY_PATH="${PULSEDIR}:${LD_LIBRARY_PATH}"
export PUBLIC_INFO=

function mecho() { echo "$@" 1>&2; }
function mdebug() {
    if [[ $debug == TRUE ]]; then
        mecho "[DEBUG] $@";
    fi
}
function vecho() {
    if [[ $verbose == TRUE ]]; then
        echo "$@";
    fi
}

function version() {
    grep -E "^###[ ]*Version:[ ]*" $0 | sed 's/###[ ]*Version:[ ]*//g'
}

function pulsesvc_version() {
    res=$(pulsesvc --version 2> /dev/null)
    if [[ $? -ne 0 ]]; then
	echo "<PLEASE INSTALL>"
    else
        printf '%s\n' "${res[@]}" | grep -F "Release Version" | sed -E 's/.*:[ ]+//'
    fi
}

function help() {
    local res=$(grep "^###" $0 | grep -vE '^(####|### whatis: )' | cut -b 5- | sed "s/{{pulsesvc_version}}/$(pulsesvc_version)/")
    if [[ ${UCSF_TOOLS} == true ]]; then
        res=$(printf '%s\n' "${res[@]}" | sed -E 's/([^/])ucsf-vpn/\1ucsf vpn/')
    fi
    printf '%s\n' "${res[@]}"
}

function connection_details() {
    mdebug "connection_details($*)"
    if [[ -z ${PUBLIC_INFO} || "$1" == "--force" ]]; then
      mdebug "Querying https://ipinfo.io/ip for public IP:"
      export PUBLIC_INFO=$(curl --silent https://ipinfo.io/json)
    fi
    mdebug "Public connection information: $PUBLIC_INFO"
    if [[ -z ${PUBLIC_INFO} ]]; then
        mdebug "ERROR: Failed to infer public IP information"
	exit 1
    fi
    echo "$PUBLIC_INFO"
}

function public_ip() {
    mdebug "public_ip($*)"
    if [[ $1 == "" ]]; then
        connection_details | grep -F "ip" | sed -E 's/[ ",]//g' | cut -d : -f 2
    else
        echo $1
    fi
}

function public_hostname() {
    mdebug "public_hostname($*)"
    connection_details | grep -F "hostname" | sed -E 's/[ ",]//g' | cut -d : -f 2
}

function is_online() {
    mdebug "is_online()"
    ping -c 1 -W 1 8.8.8.8 > /dev/null
    if [[ $? -eq 0 ]]; then
        echo TRUE
    else
        echo FALSE
    fi
}

function is_running() {
    ps -C pulsesvc > /dev/null
    if [[ $? -eq 0 ]]; then
        echo TRUE
    else
        echo FALSE
    fi
}

function is_connected() {
    mdebug "is_connected($*)"
    ## NOTE: It appears that field 'hostname' is not always returned, e.g. when
    ## calling it multiple times in a row some calls done report that field.
    ## Because of this, we test the status on the field 'org' instead.
    connection_details | grep -q -E "org.*[:].*AS5653 University of California San Francisco"
    if [[ $? -eq 0 ]]; then
        echo TRUE
    else
        echo FALSE
    fi
}
function status() {
    mdebug "status($*)"
    if [[ $online == FALSE ]]; then
      echo "No internet connection"
      exit 1
    fi
    connected=$1
    ip=$2
    if [[ $ip == "" ]]; then
      vecho "- Retrieving public IP"
      ip=$(public_ip $1)
      vecho "  => $ip"
      mdebug ip=$ip
    fi
    if [[ $connected == "" ]]; then
      vecho "- Testing if IP $ip is a registered UCSF IP number"
      connected=$(is_connected $ip)
      vecho "  => $connected"
      mdebug ip=$ip
      mdebug connected=$connected
    fi
    if [[ $connected == TRUE ]]; then
        echo "Connected to the UCSF network [$(public_hostname) ($(public_ip))]"
    else
        echo "Not connected to the UCSF network [$(public_hostname) ($(public_ip))]"
    fi
}

function start_gui() {
    if [[ $online == FALSE ]]; then
      echo "ERROR: $(status $connected $ip)"
      exit 1
    elif [[ $force == FALSE || $skip == TRUE ]]; then
      ip=$(public_ip)
      connected=$(is_connected $ip)	
      if [[ $connected == TRUE ]]; then
          if [[ $skip == TRUE ]]; then
              echo "SKIPPING: $(status $connected $ip)"
              exit 0
	  else
              echo "ERROR: $(status $connected $ip)"
              exit 1
	  fi
      fi
    fi

    if [[ $debug == TRUE ]]; then
        mdebug "call: $call"
        mdebug "call: pulseUi"
    fi
    
    if [[ $dryrun == TRUE ]]; then
        exit 0
    fi
    
    pulseUi &
}

function source_netrc() {
    local machine=$1

    local rcfile=${NETRC:-~/.netrc}
    ## No such file?
    if [[ ! -f "${rcfile}" ]]; then
        if [[ $debug == TRUE ]]; then
            mdebug "No .netrc file: $rcfile"
        fi
	return;
    fi
    if [[ $debug == TRUE ]]; then
        mdebug "Detected .netrc file: $rcfile"
    fi
    ## Force file to be accessible only by user
    chmod go-rwx "${rcfile}"

    local pattern="^[[:space:]]*machine[[:space:]]+${machine}([[:space:]]+|$)"
    local pattern="^[ \t]*machine[ \t]+${machine}([ \t]+|$)"
        
    if [[ $debug == TRUE ]]; then
        mdebug "- search: ${machine}"
        mdebug "- search pattern: ${pattern}"
    fi

    ## No such machine?
    grep -qE "${pattern}" "${rcfile}"
    if [[ $? -eq 1 ]]; then return; fi

    if [[ $debug == TRUE ]]; then
        mdebug "- found: ${machine}"
    fi
    
    bfr=$(awk "/${pattern}/{print; flag=1; next}/machine[ \t]/{flag=0} flag;" "${rcfile}")
    if [[ -z $bfr ]]; then
        mecho "[INTERNAL ERROR] Failed to extract ${machine} credentials from ${rcfile}"
	exit 1
    fi
    
    user=$(echo ${bfr} | grep -F "login" | sed -E 's/.*login[[:space:]]+([^[:space:]]+).*/\1/g')
    pwd=$(echo ${bfr} | grep -F "password" | sed -E 's/.*password[[:space:]]+([^[:space:]]+).*/\1/g')
    
    if [[ $debug == TRUE ]]; then
	mdebug "- user=${user}"
	if [[ -z "${pwd}" ]]; then
            mdebug "- pwd=<missing>"
	else
            mdebug "- pwd=<hidden>"
	fi
    fi
}

function source_ucsfvpnrc() {
    local rcfile=~/.ucsfvpnrc
    if [[ ! -f "${rcfile}" ]]; then return; fi

    mecho "DEPRECATED: The use of '${rcfile}' is deprecated. Please put credentials in '~/.netrc'.";
    
    if [[ $debug == TRUE ]]; then
        mdebug "rcfile: ${rcfile}"
    fi
    
    ## Force file to be accessible only by user
    chmod go-rwx "${rcfile}"
    
    source "${rcfile}"
    
    if [[ $debug == TRUE ]]; then
	mdebug "- user=${user}"
	if [[ -z "${pwd}" ]]; then
            mdebug "- pwd=<missing>"
	else
            mdebug "- pwd=<hidden>"
	fi
    fi
}

function prompt_user() {
    user=$1
    if [[ -n ${user} ]]; then return; fi
    mdebug "PROMPT: Asking user to enter username:"
    while [ -z ${user} ]; do
        printf "Username: " 1>&2;
	read user
	user=${user/ /}
    done
    if [[ $debug == TRUE ]]; then
	mdebug "- user=${user}"
    fi
}

function prompt_pwd() {
    pwd=$1
    if [[ -n ${pwd} ]]; then return; fi
    mdebug "PROMPT: Asking user to enter password:"
    while [ -z ${pwd} ]; do
        printf "Password: " 1>&2;
	read -s pwd
	pwd=${pwd/ /}
    done
    if [[ $debug == TRUE ]]; then
	if [[ -z "${pwd}" ]]; then
            mdebug "- pwd=<missing>"
	else
            mdebug "- pwd=<hidden>"
	fi
    fi
}

function start() {
    if [[ $online == FALSE ]]; then
      echo "ERROR: $(status $connected $ip)"
      exit 1
    elif [[ $force == FALSE || $skip == TRUE ]]; then
      ip=$(public_ip)
      connected=$(is_connected $ip)	
      if [[ $connected == TRUE ]]; then
          if [[ $skip == TRUE ]]; then
              echo "SKIPPING: $(status $connected $ip)"
              exit 0
	  else
              echo "ERROR: $(status $connected $ip)"
              exit 1
	  fi
      fi
    fi

    ## Load user credentials from file?
    source_netrc ${server}
    source_ucsfvpnrc  ## deprecated

    ## Prompt for username and password, if missing
    prompt_user ${user}
    prompt_pwd ${pwd}
    
    ## Pulse Secure options
    opts="$extras"
    opts="$opts -h ${server}"
    
    if [[ -n $user ]]; then
        opts="-u $user $opts"
    fi
    
    if [[ ! $verbose == TRUE ]]; then
        opts="-log-level 5 $opts"
    fi

    if [[ $debug == TRUE ]]; then
        mdebug "call: $call"
        mdebug "user: $user"
        if [[ -n $pwd ]]; then
            mdebug "pwd: <hidden>"
        else
            mdebug "pwd: <not specified>"
        fi
        mdebug "opts: $opts"
        mdebug "call: pulsesvc $opts -r \"${realm}\""
    fi
    
    if [[ $dryrun == TRUE ]]; then
        if [[ -n $pwd ]]; then
            echo "echo \"<pwd>\" | pulsesvc $opts -r \"${realm}\" | grep -viF password &"
	else
            echo "pulsesvc $opts -r \"${realm}\" &"
	fi
        exit 0
    fi
    
    if [[ -n $pwd ]]; then
        echo "$pwd" | pulsesvc $opts -r "${realm}" | grep -viF password &
    else
        pulsesvc $opts -r "${realm}" &
    fi
}

function stop() {
    if [[ $online == FALSE ]]; then
      echo "WARNING: $(status $connected $ip)"
    elif [[ $force == FALSE || $skip == TRUE ]]; then
      ip=$(public_ip)
      connected=$(is_connected $ip)
      if [[ $connected == FALSE ]]; then
          if [[ $skip == TRUE ]]; then
              echo "SKIPPING: $(status $connected $ip)"
              exit 0
          else
              echo "ERROR: $(status $connected $ip)"
              exit 1
          fi
      fi
      mdebug "Public IP (before): $ip"
    fi

    ## "Kill all running ncsvc services"
    pulsesvc -Kill
    echo "RESULT: Killed local VPN process"
}

function result() {
    ip=$(public_ip)
    connected=$(is_connected $ip)	
    echo "RESULT: $(status $connected $ip)"
}

## Actions
action=help

## Status
online=TRUE

## Options
server=remote.ucsf.edu
force=FALSE
skip=FALSE
debug=FALSE
verbose=FALSE
dryrun=FALSE
realm="Single-Factor Pulse Clients"
extras=
play=FALSE

## User credentials
user=
pwd=
passcode=

# Parse command-line options
while [[ $# > 0 ]]; do
    opt=$1
    if test "$1" == "--help"; then
        action=help
    elif test "$1" == "--version"; then
        action=version
    elif test "$1" == "start-gui"; then
        action=start-gui
    elif test "$1" == "start"; then
        action=start
    elif test "$1" == "status"; then
        action=status
    elif test "$1" == "details"; then
        action=details
    elif test "$1" == "stop"; then
        action=stop
    elif test "$1" == "restart"; then
        action=restart
	force=TRUE
    elif test "$1" == "toggle"; then
        action=toggle
	force=TRUE
    elif test "$1" == "log"; then
        action=log
    elif test "$1" == "troubleshoot"; then
        action=troubleshoot
    elif test "$1" == "--debug"; then
        debug=TRUE
    elif test "$1" == "--verbose"; then
        verbose=TRUE
    elif test "$1" == "--force"; then
        force=TRUE 
    elif test "$1" == "--skip"; then
        skip=TRUE
    elif test "$1" == "--dry-run"; then
        dryrun=TRUE
    elif test "$1" == "--server"; then
        shift
        server=$1
    elif test "$1" == "--realm"; then
        shift
        realm=$1
    elif test "$1" == "--user"; then
        shift
        user=$1
    elif test "$1" == "--pwd"; then
        shift
        pwd=$1
    elif test "$1" == "--passcode"; then
        shift
        passcode=$1
	if [[ ${#passcode} -ne 6 ]]; then
	    mecho "ERROR: The UCSF 2FA passcode (--passcode) must be exactly 6 digits"
	    exit 1
	fi
	if [[ ! ${passcode} =~ ^[0-9]+$ ]]; then
	    mecho "ERROR: The UCSF 2FA passcode (--passcode) must contain only digits"
	    exit 1
	fi
    elif test "$1" == "--play"; then
	play=TRUE
    else
        extras="$extras $1"
    fi
    shift
done

## Validate 'realm'
if [[ $realm == "Single-Factor Pulse Clients" ]]; then
    true
elif [[ $realm == "Dual-Factor Pulse Clients" ]]; then
    true
elif [[ $realm == "single" ]]; then
    realm="Single-Factor Pulse Clients"
elif [[ $realm == "dual" ]]; then
    realm="Dual-Factor Pulse Clients"
else
    echo "ERROR: Unknown value on option --realm: $realm"
    exit 1    
fi

if [[ $debug == TRUE ]]; then
    mdebug "call: $call"
    mdebug "action: $action"
    mdebug "play: $play"
    mdebug "VPN server: $server"
    mdebug "Realm: $realm"
    mdebug "verbose: $verbose"
    mdebug "force: $force"
    mdebug "skip: $skip"
    mdebug "dryrun: $dryrun"
    mdebug "extras: $extras"
    mdebug "user: $user"
    if [[ -z "${pwd}" ]]; then
        mdebug "pwd=<missing>"
    else
        mdebug "pwd=<hidden>"
    fi
fi

if [[ $action == "version" ]]; then
    version
    exit 0
elif [[ $action == "help" ]]; then
    help 
    exit 0
fi

## Check internet connection
online=$(is_online)
mdebug "online: $online"

if [[ $action == "status" ]]; then
    status
    exit $?
elif [[ $action == "details" ]]; then
    connection_details
    exit $?
elif [[ $action == "start-gui" ]]; then
    start_gui
    res=$?
    if [[ $res -ne 0 ]]; then exit $res; fi
    if [[ $play == TRUE ]]; then
        ## Check for 'xdotool'
        which xdotool 2> /dev/null
        if [[ $? -ne 0 ]]; then
            mecho "ERROR: Cannot enter credentials in GUI, because 'xdotool' could not be located."
	    exit 1
	fi

        ## Load user credentials from file?
        source_netrc ${server}
        source_ucsfvpnrc  ## deprecated
    
        ## Prompt for username and password, if missing
        prompt_user ${user}
        prompt_pwd ${pwd}
	
        sleep 1
        wid=$(xdotool search --all --onlyvisible --pid $(pidof pulseUi) --name "Pulse Secure")
        if [[ -z $wid ]]; then
            mecho "ERROR: Failed to locate the Pulse Secure GUI window"
	    exit 1
        fi
        mdebug "Pulse Secure Window ID: $wid"
        mdebug "Attempting to click on 'Connect'"
        xdotool search --all --onlyvisible --pid $(pidof pulseUi) --name "Pulse Secure" windowfocus --sync windowraise mousemove --window %1 --sync 0 0 sleep 0.1 click 1 sleep 0.1 key --delay 50 --repeat 7 Tab sleep 0.1 key Return sleep 2 key --delay 100 --repeat 2 Tab
	
	sleep 0.5
	wid2=$(xdotool search --all --onlyvisible --name "Pulse Secure")
        mdebug "Pulse Secure Window IDs: $wid2"
	wid2=$(echo "$wid2" | grep -vF $wid)
        mdebug "Pulse Secure Popup Window ID: $wid2"
        if [[ -z $wid2 ]]; then
            mecho "ERROR: Failed to locate the Pulse Secure GUI popup window"
	    exit 1
        fi
        mdebug "Clicking on 'Proceed'"
        xdotool windowactivate --sync $wid2 key --repeat 2 Tab key Return
	sleep 1
	
        mdebug "Entering user credentials (username and password)"
        xdotool windowactivate --sync $wid2 type "$user"
        xdotool windowactivate --sync $wid2 key Tab type "$pwd"
        xdotool windowactivate --sync $wid2 key Tab Down Tab Return

	
	sleep 2
	wid3=$(xdotool search --all --onlyvisible --name "Pulse Secure")
        mdebug "Pulse Secure Window IDs: $wid3"
	wid3=$(echo "$wid3" | grep -vF $wid)
        mdebug "Pulse Secure Popup Window ID: $wid3"
        if [[ -z $wid3 ]]; then
            mecho "ERROR: Failed to locate the Pulse Secure GUI popup window"
	    exit 1
        fi
        if [[ -n $passcode ]]; then
            mdebug "Entering 2FA passcode"
            xdotool windowactivate --sync $wid3 type "$passcode"
            xdotool windowactivate --sync $wid3 key Return
	fi
    fi
    exit $res
elif [[ $action == "start" ]]; then
    start
    res=$?
    sleep 4
    online=$(is_online)
    result
    exit $res
elif [[ $action == "stop" ]]; then
    stop
    res=$?
    sleep 1
    online=$(is_online)
    result
    exit $res
elif [[ $action == "restart" ]]; then
    stop
    sleep 1
    online=$(is_online)
    start
    sleep 4
    res=$?
    online=$(is_online)
    result
    exit $res
elif [[ $action == "toggle" ]]; then
    connected=$(is_connected $ip)
    mdebug "connected: $connected"
    if [[ $connected == FALSE ]]; then
      start
      sleep 4
      res=$?
    else
      stop
      sleep 1
      res=$?
    fi
    online=$(is_online)
    result
    exit $res
elif [[ $action == "log" ]]; then
    LOGFILE=$HOME/.pulse_secure/pulse/pulsesvc.log
    mdebug "Displaying log file: $LOGFILE"
    if [[ ! -f $LOGFILE ]]; then
	mecho "[WARN] No such log file: $LOGFILE"
	exit 1
    fi
    cat $LOGFILE
elif [[ $action == "troubleshoot" ]]; then
    LOGFILE=$HOME/.pulse_secure/pulse/pulsesvc.log
    mdebug "Scanning log file: $LOGFILE"
    if [[ ! -f $LOGFILE ]]; then
	mecho "[WARN] No such log file: $LOGFILE"
	exit 1
    fi
    grep -q -F Error $LOGFILE &> /dev/null
    if [[ $? -ne 0 ]]; then
	mecho "[OK] No errors found: $LOGFILE"
	exit 0
    fi
    
    mecho "[ERROR] Errors found: $LOGFILE"
    grep -F Error $LOGFILE | >&2 tail -3 
    exit 1
fi
