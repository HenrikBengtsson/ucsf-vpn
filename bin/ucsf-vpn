#! /usr/bin/env bash
### Connect to and Disconnect from the UCSF VPN
###
### Usage:
###  ucsf-vpn <command> [options]
###
### Commands:
###  start            Connect to UCSF VPN
###  stop             Disconnect from UCSF VPN
###  restart          Disconnect and reconnect to UCSF VPN
###  toggle           Connect to or disconnect from UCSF VPN
###
###  status           Display UCSF VPN connection status
###  details          Display connection details
###  log              Display the log file
###  troubleshoot     Scan the log file for errors and more.
###
###  open-gui         Open the Pulse Secure GUI
###  close-gui        Close the Pulse Secure GUI (and any VPN connections)
###
### Options:
###  --user <user>    UCSF Active Directory ID (username)
###  --pwd <pwd>      UCSF Active Directory ID password
###  --token <token>  One-time two-factor authentication (2FA) token (Duo or
###                   YubiKey). If 'true' (default), user is prompted to enter
###                   the token. If 'push', authentication is done via
###                   Duo Push (approve and confirm in Duo app). If 'phone',
###                   authenatication is done by a phone call ("press any key").
###                   If 'false', 2FA is not used.
###
###  --gui            Connect to VPN via Pulse Secure GUI (default)
###  --no-gui         Connect to VPN via Pulse Secure CLI
###  --speed <factor> Control speed of --gui interactions (default is 1.0)
###
###  --server <host>  VPN server (default is remote.ucsf.edu)
###  --realm <realm>  VPN realm (default is 'Dual-Factor Pulse Clients')
###  --url <url>      VPN URL (default is https://{{server}}/pulse)
###                   (only used with --gui)
###
###  --skip           If already fulfilled, skip command
###  --force          Force running the command
###  --verbose        Verbose output
###  --help           This help
###  --version        Display version
###
### Any other options are passed to Pulse Secure CLI as is (only --no-gui).
###
### Examples:
###  ucsf-vpn start --user alice --token push
###  ucsf-vpn start --user alice --pwd secrets --token true
###  ucsf-vpn start --token phone
###  ucsf-vpn start
###  ucsf-vpn stop
###
### User credentials:
### If user credentials (--user and --pwd) are neither specified nor given
### in ~/.netrc, then you will be prompted to enter them. To specify them
### in ~/.netrc file, use the following:
###
###   machine remote.ucsf.edu
###       login alice
###       password secrets
###
### For security, the ~/.netrc file should be readable only by
### the user / owner of the file. If not, then 'ucsf-vpn start' will
### set its permission accordingly (by calling chmod go-rwx ~/.netrc).
###
### Requirements:
### * Junos Pulse Secure client (>= 5.3) (installed: {{pulsesvc_version}})
### * Ports 4242 (UDP) and 443 (TCP)
### * `curl`
### * `xdotool` (when using 'ucsf-vpn start --gui')
### * No need for sudo rights to run :)
###
### Pulse Secure GUI configuration:
### Calling 'ucsf-vpn start --gui' will, if missing, automatically add a valid
### UCSF VPN connection to the Pulse Secure GUI with the following details:
###  - Name: UCSF
###  - URL: https://remote.ucsf.edu/pulse
### You may change the name to you own liking.
###
### Troubleshooting:
### * Verify your username and password at https://remote.ucsf.edu/.
###   This should be your UCSF Active Directory ID (username); neither
###   MyAccess SFID (e.g. 'sf*****') nor UCSF email address will work.
### * Make sure ports 4242 & 443 are not used by other processes
### * If you are using the Pulse Secure GUI (`ucsf-vpn open-gui`), use
###   'https://remote.ucsf.edu/pulse' as the URL when adding a new
###   connection.
### * Run 'ucsf-vpn troubleshoot' to inspect the Pulse Secure logs and more.
###
### Useful resources:
### * UCSF VPN information:
###   - https://software.ucsf.edu/content/vpn-virtual-private-network
### * UCSF Web-based VPN Interface:
###   - https://remote.ucsf.edu/
### * UCSF Two-Factory Authentication (2FA):
###   - https://it.ucsf.edu/services/duo-two-factor-authentication
### * UCSF Active Directory Account Manager:
###   - https://pwmanage.ucsf.edu/pm/
###
### Version: 3.1.1-9000
### Copyright: Henrik Bengtsson (2016-2017)
### License: GPL (>= 2.1) [https://www.gnu.org/licenses/gpl.html]
### Source: https://github.com/HenrikBengtsson/ucsf-vpn
call="$0 $*"

export PULSEPATH=${PULSEPATH:-/usr/local/pulse}
export PATH="${PULSEPATH}:${PATH}"
export LD_LIBRARY_PATH="${PULSEPATH}:${LD_LIBRARY_PATH}"
export PUBLIC_INFO=

function mecho() { echo "$@" 1>&2; }
function mdebug() {
    if [[ $debug == TRUE ]]; then
        mecho "[DEBUG] $*";
    fi
}
function merror() {
    mecho "ERROR: $*";
    exit 1
}
function vecho() {
    if [[ $verbose == TRUE ]]; then
        echo "$@";
    fi
}

function version() {
    grep -E "^###[ ]*Version:[ ]*" "$0" | sed 's/###[ ]*Version:[ ]*//g'
}

function pulsesvc_version() {
    res=$(pulsesvc --version 2> /dev/null)
    # shellcheck disable=SC2181
    if [[ $? -ne 0 ]]; then
        echo "<PLEASE INSTALL>"
    else
        printf "%s\\n" "${res[@]}" | grep -F "Release Version" | sed -E 's/.*:[ ]+//'
    fi
}

function help() {
    local res=
    res=$(grep "^###" "$0" | grep -vE '^(####|### whatis: )' | cut -b 5- | sed "s/{{pulsesvc_version}}/$(pulsesvc_version)/")
    if [[ ${UCSF_TOOLS} == true ]]; then
        res=$(printf "%s\\n" "${res[@]}" | sed -E 's/([^/])ucsf-vpn/\1ucsf vpn/')
    fi
    printf "%s\\n" "${res[@]}"
}

function connection_details() {
    mdebug "connection_details()"
    if [[ -z ${PUBLIC_INFO} ]]; then
      mdebug "Querying https://ipinfo.io/ip for public IP:"
      PUBLIC_INFO=$(curl --silent https://ipinfo.io/json)
      export PUBLIC_INFO
    fi
    mdebug "Public connection information: $PUBLIC_INFO"
    if [[ -z ${PUBLIC_INFO} ]]; then
        merror "Failed to infer public IP information"
    fi
    echo "$PUBLIC_INFO"
}

function public_ip() {
    mdebug "public_ip($*)"
    if [[ $1 == "" ]]; then
        connection_details | grep -F "ip" | sed -E 's/[ ",]//g' | cut -d : -f 2
    else
        echo "$1"
    fi
}

function public_hostname() {
    mdebug "public_hostname()"
    connection_details | grep -F "hostname" | sed -E 's/[ ",]//g' | cut -d : -f 2
}

function is_online() {
    mdebug "is_online()"
    if ping -c 1 -W 1 8.8.8.8 > /dev/null; then
        echo TRUE
    else
        echo FALSE
    fi
}

function is_pulsesvc_running() {
    if ps -C pulsesvc > /dev/null; then
        echo TRUE
    else
        echo FALSE
    fi
}

function is_pulseUi_running() {
    if ps -C pulseUi > /dev/null; then
        echo TRUE
    else
        echo FALSE
    fi
}

function pulseUi_find_connection() {
    local config_home="$HOME/.pulse_secure/pulse"
    local confile="$config_home/.pulse_Connections.txt"
    [[ -f "$confile" ]] || pulseUi_add_connection
    [[ -f "$confile" ]] || merror "No Pulse GUI connection file: $confile"
    mdebug "Pulse connections file: $confile"
    mdebug "$(< "$confile")"
       
    # shellcheck disable=SC2207
    IFS=$'\r\n' cons=( $(grep -E "^[ \\t]*{.+}[ \\t]*$" < "$confile") )
    mdebug "Number of connections: ${#cons[@]}"
    mdebug "Searching for VPN URL: $url"
    
    local idx=-1
    for ii in "${!cons[@]}"; do
	con="${cons[$ii]/^ */}"
	mdebug "- connection $ii: $con"
        if echo "$con" | grep -q -F "\"$url\"" &> /dev/null; then
	    idx=$ii
	    break
	fi
    done

    mdebug "Index of connection found: $idx"
    
    echo "$idx"
}

function pulseUi_add_connection() {
    local config_home="$HOME/.pulse_secure/pulse"
    local confile="$config_home/.pulse_Connections.txt"
    name="UCSF"
    mdebug "Pulse connections file: $confile"
    con="{\"connName\": \"$name\", \"preferredCert\": \"\", \"baseUrl\": \"$url\"}"
    mdebug "Appending connection: $con"
    echo "$con" >> "$confile"
    mecho "Appended missing '$name' connection: $url"
}

function is_connected() {
    mdebug "is_connected($*)"
    ## NOTE: It appears that field 'hostname' is not always returned, e.g. when
    ## calling it multiple times in a row some calls done report that field.
    ## Because of this, we test the status on the field 'org' instead.
    connection_details | grep -q -E "org.*[:].*AS5653 University of California San Francisco"
    # shellcheck disable=SC2181
    if [[ $? -eq 0 ]]; then
        echo TRUE
    else
        echo FALSE
    fi
}
function status() {
    mdebug "status($*)"
    if [[ $online == FALSE ]]; then
      merror "No internet connection"
    fi
    connected=$1
    ip=$2
    if [[ $ip == "" ]]; then
      vecho "- Retrieving public IP"
      ip=$(public_ip "$1")
      vecho "  => $ip"
      mdebug "ip=$ip"
    fi
    if [[ "$connected" == "" ]]; then
      vecho "- Testing if IP $ip is a registered UCSF IP number"
      connected=$(is_connected "$ip")
      vecho "  => $connected"
      mdebug "ip=$ip"
      mdebug "connected=$connected"
    fi
    if [[ "$connected" == TRUE ]]; then
        echo "Connected to the UCSF network [$(public_hostname) ($(public_ip))]"
    else
        echo "Not connected to the UCSF network [$(public_hostname) ($(public_ip))]"
    fi
}

function start_gui() {
    if [[ $(is_pulseUi_running) == TRUE ]]; then
        mecho "SKIPPING: Pulse Secure GUI is already running"
        return
    fi
    
    ## Start the Pulse Secure GUI
    ## NOTE: Sending stderr to dev null to silence warnings on
    ## "(pulseUi:26614): libsoup-CRITICAL **: soup_cookie_jar_get_cookies:
    ##  assertion 'SOUP_IS_COOKIE_JAR (jar)' failed"
    pulseUi 2> /dev/null &
}

function open_gui() {
    if [[ $online == FALSE ]]; then
      merror "$(status "$connected" "$ip")"
    elif [[ $force == FALSE || $skip == TRUE ]]; then
      ip=$(public_ip)
      connected=$(is_connected "$ip")
      if [[ "$connected" == TRUE ]]; then
          if [[ $skip == TRUE ]]; then
              mecho "[SKIPPING]: $(status "$connected" "$ip")"
              exit 0
          else
              merror "$(status "$connected" "$ip")"
          fi
      fi
    fi

    if [[ $debug == TRUE ]]; then
        mdebug "call: $call"
        mdebug "call: pulseUi"
    fi
    
    if [[ $dryrun == TRUE ]]; then
        exit 0
    fi

    ## Start the Pulse Secure GUI
    start_gui
}

function close_gui() {
    if [[ $(is_pulseUi_running) == FALSE ]]; then return; fi

    mdebug "Closing Pulse Secure GUI"

    ## Try with 'xdotool'?
    if which xdotool &> /dev/null; then
        xdotool search --all --onlyvisible --pid "$(pidof pulseUi)" --name "Pulse Secure" windowkill
    else
        pkill -QUIT pulseUi && mdebug "Killed Pulse Secure GUI"
    fi
}

function wait_for_pulse_window_to_close() {
    wid=$1		
    mdebug "Waiting for Pulse Secure Window ID ($wid) to close ..."
    while true; do
       wids=$(xdotool search --all --onlyvisible --name "Pulse Secure")
       echo "$wids" | grep -q "$wid" && break
       sleep 0.2
    done
    mdebug "Waiting for Pulse Secure Window ID ($wid) to close ... done"
}

function source_netrc() {
    local machine=$1

    local rcfile=${NETRC:-~/.netrc}
    ## No such file?
    if [[ ! -f "${rcfile}" ]]; then
        if [[ $debug == TRUE ]]; then
            mdebug "No .netrc file: $rcfile"
        fi
        return;
    fi
    if [[ $debug == TRUE ]]; then
        mdebug "Detected .netrc file: $rcfile"
    fi
    ## Force file to be accessible only by user
    chmod go-rwx "${rcfile}"

    local pattern="^[[:space:]]*machine[[:space:]]+${machine}([[:space:]]+|$)"
    local pattern="^[ \\t]*machine[ \\t]+${machine}([ \\t]+|$)"
        
    if [[ $debug == TRUE ]]; then
        mdebug "- search: ${machine}"
        mdebug "- search pattern: ${pattern}"
    fi

    ## No such machine?
    grep -q -E "${pattern}" "${rcfile}"
    # shellcheck disable=SC2181
    if [[ $? -ne 0 ]]; then
	mdebug "- no such machine: $machine"
	return 0
    elif [[ $debug == TRUE ]]; then
        mdebug "- found: ${machine}"
    fi
    
    bfr=$(awk "/${pattern}/{print; flag=1; next}/machine[ \\t]/{flag=0} flag;" "${rcfile}")
    [[ -z $bfr ]] && merror "Internal error - failed to extract ${machine} credentials from ${rcfile}"
    
    user=$(echo "${bfr}" | grep -F "login" | sed -E 's/.*login[[:space:]]+([^[:space:]]+).*/\1/g')
    pwd=$(echo "${bfr}" | grep -F "password" | sed -E 's/.*password[[:space:]]+([^[:space:]]+).*/\1/g')
    
    if [[ $debug == TRUE ]]; then
        mdebug "- user=${user}"
        if [[ -z "${pwd}" ]]; then
            mdebug "- pwd=<missing>"
        else
            mdebug "- pwd=<hidden>"
        fi
    fi
}

function source_ucsfvpnrc() {
    local rcfile=~/.ucsfvpnrc
    if [[ ! -f "${rcfile}" ]]; then return; fi
    merror "The use of '${rcfile}' is defunct. Please put credentials in '~/.netrc'."
}

function prompt_user() {
    user=$1
    if [[ -n "${user}" ]]; then return; fi
    mdebug "PROMPT: Asking user to enter username:"
    while [ -z "${user}" ]; do
        printf "Enter username: " 1>&2;
        read -r user
        user=${user/ /}
    done
    if [[ $debug == TRUE ]]; then
        mdebug "- user=${user}"
    fi
}

function prompt_pwd() {
    pwd=$1
    if [[ -n "${pwd}" ]]; then return; fi
    mdebug "PROMPT: Asking user to enter password:"
    while [ -z "${pwd}" ]; do
        printf "Enter password: " 1>&2;
        read -r -s pwd
        pwd=${pwd/ /}
    done
    mecho "<password>"

    if [[ $debug == TRUE ]]; then
        if [[ -z "${pwd}" ]]; then
            mdebug "- pwd=<missing>"
        else
            mdebug "- pwd=<hidden>"
        fi
    fi
}

function is_token_valid() {
    token=$1

    ## Hardcoded methods
    if [[ ${token} =~ ^phone[1-9]*$ ]]; then
        ## Tested with 'phone' and 'phone2', but for some reason
        ## the same phone number is called although I've got two
        ## different registered.  Also 'phone1' and 'phone3' gives
        ## an error.
        mdebug "Will authenticate via a phone call from Duo"
        echo TRUE
        return
    elif [[ ${token} == "push" ]]; then
        mdebug "Will authenticate via Duo Push (approve and confirm in Duo app)"
        echo TRUE
        return
    elif [[ ${token} == "sms" ]]; then
        mdebug "Will send token via SMS"
        echo TRUE
        return
    elif [[ ${token} == "false" ]]; then
        mdebug "Will not use token (in the form)"
        echo TRUE
        return
    fi
    
    ## YubiKey token (44 lower-case letters)
    if [[ ${#token} -eq 44 ]] && [[ ${token} =~ ^[a-z]+$ ]]; then
        mdebug "YubiKey token detected"
        echo TRUE
        return
    fi
    
    ## Duo 6-digit token
    if [[ ${#token} -eq 6 ]] && [[ ${token} =~ ^[0-9]+$ ]]; then
        mdebug "Duo token detected"
        echo TRUE
        return
    fi

    echo FALSE
}

function prompt_token() {
    token=$1
    if [[ ${token} == "true" ]]; then token=; fi
    if [[ -n "${token}" ]]; then return; fi
  
    mdebug "PROMPT: Asking user to enter one-time token:"
    while [ -z "${token}" ]; do
        printf "Enter 'push', 'phone', 'sms', a 6-digit Duo token, or press your YubiKey: " 1>&2;
        read -r -s token
        token=${token/ /}
        if [[ $(is_token_valid "$token") == FALSE ]]; then
            printf "\\nERROR: Not a valid token ('phone', 'sms', Duo: 6 digits or 'push', YubiKey: 44 letters)\\n"
            token=
        fi
    done
    mecho "<valid token>"

    if [[ $debug == TRUE ]]; then
        if [[ -z "${token}" ]]; then
            mdebug "- token=<missing>"
        else
            mdebug "- token=<hidden>"
        fi
    fi
}

function start() {
    ## Validate request    
    if [[ "$realm" == "Dual-Factor Pulse Clients" ]]; then
        if [[ $gui == FALSE ]]; then
            merror "Using --realm '$realm' (two-factor authentication; 2FA) is not supported when using --no-gui"
	fi
    elif [[ "$realm" == "Single-Factor Pulse Clients" ]]; then
        if [ -n "${token}" ] && [ ${token} != false ]; then
            merror "Passing a --token '$token' with --realm '$realm' (two-factor authentication; 2FA) does not make sense"
	fi
    fi
    if [ -n "${token}" ] && [ ${token} != false ]; then
        if [[ $gui == FALSE ]]; then
            merror "Using --token '$token' suggests two-factor authentication (2FA), which is currently not supported when using --no-gui"
        fi
    fi
    
    if [[ $online == FALSE ]]; then
      merror "$(status "$connected" "$ip")"
    elif [[ $force == FALSE || $skip == TRUE ]]; then
      ip=$(public_ip)
      connected=$(is_connected "$ip")
      
      if [[ "$connected" == TRUE ]]; then
          if [[ $skip == TRUE ]]; then
              mecho "SKIPPING: $(status "$connected" "$ip")"
              exit 0
          else
              merror "$(status "$connected" "$ip")"
          fi
      fi
    fi

    ## Check for valid connection in Pulse Secure GUI
    local conidx=-1
    if [[ $gui == TRUE ]]; then
	## If Pulse Secure GUI is open, we need to close it
	## before peeking at its connections config file.
        if [[ $(is_pulseUi_running) == TRUE ]]; then
	    close_gui
            sleep "$(div 0.5 "$speed")"
	fi
        conidx=$(pulseUi_find_connection)	
	[[ $conidx -eq -1 ]] && pulseUi_add_connection
        conidx=$(pulseUi_find_connection)	
	[[ $conidx -eq -1 ]] && merror "Pulse Secure GUI does not have a connection for the UCSF VPN: $url"
    fi
    
    ## Load user credentials from file?
    source_netrc "${server}"
    source_ucsfvpnrc  ## deprecated

    ## Prompt for username and password, if missing
    prompt_user "${user}"
    prompt_pwd "${pwd}"

    ## Prompt for 2FA token?
    if [[ "$realm" == "Dual-Factor Pulse Clients" ]]; then
        ## Prompt for one-time token, if requested
        prompt_token "${token}"
    fi

    if [[ $gui == TRUE ]]; then
        ## Check for 'xdotool'        
        which xdotool &> /dev/null || merror "Cannot enter credentials in GUI, because 'xdotool' could not be located."

        ## Start Pulse Secure GUI
	start_gui
        
        sleep "$(div 1.0 "$speed")"
        wid=$(xdotool search --all --onlyvisible --pid "$(pidof pulseUi)" --name "Pulse Secure")
        if [[ -z "$wid" ]]; then
            merror "Failed to locate the Pulse Secure GUI window"
        fi
        mecho "Pulse Secure GUI automation:"
        mdebug "Pulse Secure Window ID: $wid"
        mdebug "Clicking pulseUi 'Connect': $((7 + 2 * conidx)) TABs + ENTER"
        cmd="xdotool search --all --onlyvisible --pid $(pidof pulseUi) --name 'Pulse Secure' windowmap --sync windowactivate --sync windowfocus --sync windowraise mousemove --window %1 --sync 0 0 sleep 0.1 click 1 sleep 0.1 key --delay 50 --repeat "$((7 + 2 * conidx))" Tab sleep 0.1 key Return"
        mdebug " - $cmd"
        mecho " 1. selecting connection and clicking 'Connect'"
	eval "$cmd"
	
        mdebug "Minimizing Pulse Secure GUI"
        xdotool windowminimize "$wid"
        
        sleep "$(div 2.0 "$speed")"
        wid2=$(xdotool search --all --onlyvisible --name "Pulse Secure")
        mdebug "Pulse Secure Window IDs: $wid2"
        wid2=$(echo "$wid2" | grep -vF "$wid")
        mdebug "Pulse Secure Popup Window ID: $wid2"
        if [[ -z "$wid2" ]]; then
            merror "Failed to locate the Pulse Secure GUI popup window"
        fi

        ## Click-through UCSF announcement message?
        if [[ ${notification} == TRUE ]]; then
            mdebug "Clicking on 'Proceed'"
            cmd="xdotool windowactivate --sync $wid2 key --delay 50 --repeat 2 Tab key Return"
            mdebug " - $cmd"
            eval "$cmd"
            mecho " 2. clicking through UCSF notification popup window"
            sleep "$(div 2.0 "$speed")"
        fi
        
        mdebug "Entering user credentials (username and password)"
        xdotool windowactivate --sync "$wid2" type "$user"
        xdotool windowactivate --sync "$wid2" key --delay 50 Tab type "$pwd"
	## Single- or Dual-Factor Pulse Clients?
        local extra=
	[[ "$realm" == "Dual-Factor Pulse Clients" ]] && extra="Down"
        cmd="xdotool windowactivate --sync $wid2 key --delay 50 Tab $extra Tab Return"
        mdebug " - $cmd"
        eval "$cmd"
        mecho " 3. entering user credentials and selecting realm"


        if [[ ${token} != false ]]; then
            mdebug "Using two-factor authentication (2FA) token"
            
            sleep "$(div 1.0 "$speed")"
            wid3=$(xdotool search --all --onlyvisible --name "Pulse Secure")
            mdebug "Pulse Secure Window IDs: $wid3"
            wid3=$(echo "$wid3" | grep -vF "$wid")
            mdebug "Pulse Secure Popup Window ID: $wid3"
            if [[ -z "$wid3" ]]; then
                merror "Failed to locate the Pulse Secure GUI popup window"
            fi
            
            mdebug "Entering token"
            mecho " 4. entering 2FA token"
            cmd="xdotool windowactivate --sync $wid3 type $token"
            mdebug " - $cmd"
            eval "$cmd"
            cmd="xdotool windowactivate --sync $wid3 key Return"
            mdebug " - $cmd"
            eval "$cmd"

            ## Wait for popup window to close
	    wait_for_pulse_window_to_close "$wid3"
	else
            ## Wait for popup window to close
	    wait_for_pulse_window_to_close "$wid2"
        fi
        mecho " 5. connecting ..."
    else
      if [[ "$realm" == "Dual-Factor Pulse Clients" ]]; then
          merror "Using --realm '$realm' (two-factor authentication; 2FA) is not supported when using --no-gui"
      fi
      if [ -n "${token}" ] && [ ${token} != false ]; then
          merror "Using --token '$token' suggests two-factor authentication (2FA), which is currently not supported when using --no-gui"
      fi
      ## Pulse Secure options
      opts="$extras"
      opts="$opts -h ${server}"
      
      if [[ -n $user ]]; then
          opts="-u $user $opts"
      fi
      
      if [[ ! $verbose == TRUE ]]; then
          opts="-log-level 5 $opts"
      fi
  
      if [[ $debug == TRUE ]]; then
          mdebug "call: $call"
          mdebug "user: $user"
          if [[ -n $pwd ]]; then
              mdebug "pwd: <hidden>"
          else
              mdebug "pwd: <not specified>"
          fi
          mdebug "opts: $opts"
          mdebug "call: pulsesvc $opts -r \"${realm}\""
      fi
      
      if [[ $dryrun == TRUE ]]; then
          if [[ -n $pwd ]]; then
              echo "echo \"<pwd>\" | pulsesvc $opts -r \"${realm}\" | grep -viF password &"
          else
              echo "pulsesvc $opts -r \"${realm}\" &"
          fi
          exit 0
      fi
      
      if [[ -n $pwd ]]; then
          echo "$pwd" | pulsesvc "$opts" -r "${realm}" | grep -viF password &
      else
          pulsesvc "$opts" -r "${realm}" &
      fi
    fi
}

function stop() {
    if [[ $online == FALSE ]]; then
      mecho "WARNING: $(status "$connected" "$ip")"
    elif [[ $force == FALSE || $skip == TRUE ]]; then
      ip=$(public_ip)
      connected=$(is_connected "$ip")
      if [[ "$connected" == FALSE ]]; then
          ## Close/kill the Pulse Secure GUI
          close_gui
    
          if [[ $skip == TRUE ]]; then
              mecho "[SKIPPING] $(status "$connected" "$ip")"
              exit 0
          else
              merror "$(status "$connected" "$ip")"
          fi
      fi
      mdebug "Public IP (before): $ip"
    fi

    ## Close/kill the Pulse Secure GUI
    close_gui
    
    ## Kill any running pulsesvc processes
    pulsesvc -Kill
    mdebug "Killed local VPN process"
}

function result() {
    ip=$(public_ip)
    connected=$(is_connected "$ip")
    echo "RESULT: $(status "$connected" "$ip")"
}

function div() {
    if [ "$2" == "1" ] || [ "$2" == "1.0" ]; then
        echo "$1"
    else
	# shellcheck disable=SC2003
        expr "$1/$2" | bc -l
    fi
}

## Actions
action=help

## Status
online=TRUE

## Options
server=remote.ucsf.edu
url=
force=FALSE
skip=FALSE
debug=FALSE
verbose=FALSE
dryrun=FALSE
realm=
extras=
gui=TRUE
notification=TRUE
speed=1.0

## User credentials
user=
pwd=
token=default

# Parse command-line options
while [[ $# -gt 0 ]]; do
    if test "$1" == "--help"; then
        action=help
    elif test "$1" == "--version"; then
        action=version
    elif test "$1" == "open-gui"; then
        action=open-gui
    elif test "$1" == "close-gui"; then
        action=close-gui
    elif test "$1" == "start"; then
        action=start
    elif test "$1" == "status"; then
        action=status
    elif test "$1" == "details"; then
        action=details
    elif test "$1" == "stop"; then
        action=stop
    elif test "$1" == "restart"; then
        action=restart
        force=TRUE
    elif test "$1" == "toggle"; then
        action=toggle
        force=TRUE
    elif test "$1" == "log"; then
        action=log
    elif test "$1" == "troubleshoot"; then
        action=troubleshoot
    elif test "$1" == "--debug"; then
        debug=TRUE
    elif test "$1" == "--verbose"; then
        verbose=TRUE
    elif test "$1" == "--force"; then
        force=TRUE 
    elif test "$1" == "--skip"; then
        skip=TRUE
    elif test "$1" == "--dry-run"; then
        dryrun=TRUE
    elif test "$1" == "--url"; then
        shift
        url=$1
    elif test "$1" == "--server"; then
        shift
        server=$1
    elif test "$1" == "--realm"; then
        shift
        realm=$1
    elif test "$1" == "--user"; then
        shift
        user=$1
    elif test "$1" == "--pwd"; then
        shift
        pwd=$1
    elif test "$1" == "--token"; then
        shift
        token=$1
        if [[ ${token} == "true" ]]; then
            mdebug "Will prompt user for 2FA token"
        elif [[ ${token} == "false" ]]; then
            mdebug "Will not use 2FA authenatication"
        elif [[ $(is_token_valid "$token") == FALSE ]]; then
            merror "The token (--token) must be 6 digits (Duo) or 44 letters (YubiKey)"
            exit 1
        fi
    elif test "$1" == "--gui"; then
        gui=TRUE
    elif test "$1" == "--no-gui"; then
        gui=FALSE
    elif test "$1" == "--notification"; then
        notification=TRUE
    elif test "$1" == "--no-notification"; then
        notification=FALSE
    elif test "$1" == "--speed"; then
        shift
        speed=$1
        if [[ ! ${speed} =~ ^[0-9]+[.0-9]*$ ]]; then
            merror "Invalid --speed argument: $speed"
        fi
    else
        extras="$extras $1"
    fi
    shift
done

## Use default URL?
[[ -z "$url" ]] && url=https://${server}/pulse

## Validate 'realm'
if [[ -z $realm ]]; then
    if [[ $gui == TRUE ]]; then
        realm="Dual-Factor Pulse Clients"
    else
        realm="Single-Factor Pulse Clients"
    fi
fi
if [[ $realm == "Single-Factor Pulse Clients" ]]; then
    true
elif [[ $realm == "Dual-Factor Pulse Clients" ]]; then
    true
elif [[ $realm == "single" ]]; then
    realm="Single-Factor Pulse Clients"
elif [[ $realm == "dual" ]]; then
    realm="Dual-Factor Pulse Clients"
else
    merror "Unknown value on option --realm: $realm"
fi

if [[ $token == default ]]; then
    if [[ $realm == "Dual-Factor Pulse Clients" ]]; then
        token=true
    else
        token=false
    fi
fi

if [[ $debug == TRUE ]]; then
    mdebug "call: $call"
    mdebug "action: $action"
    mdebug "gui: $gui"
    mdebug "speed: $speed"
    mdebug "VPN server: $server"
    mdebug "Realm: '$realm'"
    mdebug "verbose: $verbose"
    mdebug "force: $force"
    mdebug "skip: $skip"
    mdebug "dryrun: $dryrun"
    mdebug "extras: $extras"
    mdebug "user: $user"
    if [[ -z "${pwd}" ]]; then
        mdebug "pwd=<missing>"
    else
        mdebug "pwd=<hidden>"
    fi
    if [[ -z "${token}" ]]; then
        mdebug "token=<missing>"
    elif [[ "${token}" == "true" ]]; then
        mdebug "token=<prompt>"
    else
        mdebug "token=<hidden>"
    fi
fi

if [[ $action == "version" ]]; then
    version
    exit 0
elif [[ $action == "help" ]]; then
    help 
    exit 0
fi

## Check internet connection
online=$(is_online)
mdebug "online: $online"

if [[ $action == "status" ]]; then
    status
    exit $?
elif [[ $action == "details" ]]; then
    connection_details
    exit $?
elif [[ $action == "open-gui" ]]; then
    open_gui
    res=$?
    exit $res
elif [[ $action == "close-gui" ]]; then
    close_gui
    res=$?
    exit $res
elif [[ $action == "start" ]]; then
    start
    res=$?
    sleep 4
    online=$(is_online)
    result
    exit $res
elif [[ $action == "stop" ]]; then
    stop
    res=$?
    sleep 1
    online=$(is_online)
    result
    exit $res
elif [[ $action == "restart" ]]; then
    stop
    sleep 1
    online=$(is_online)
    start
    sleep 4
    res=$?
    online=$(is_online)
    result
    exit $res
elif [[ $action == "toggle" ]]; then
    connected=$(is_connected "$ip")
    mdebug "connected: $connected"
    if [[ "$connected" == FALSE ]]; then
      start
      sleep 4
      res=$?
    else
      stop
      sleep 1
      res=$?
    fi
    online=$(is_online)
    result
    exit $res
elif [[ $action == "log" ]]; then
    LOGFILE=$HOME/.pulse_secure/pulse/pulsesvc.log
    mdebug "Displaying log file: $LOGFILE"
    if [[ ! -f $LOGFILE ]]; then
        mecho "[WARN] No such log file: $LOGFILE"
        exit 1
    fi
    cat "$LOGFILE"
elif [[ $action == "troubleshoot" ]]; then
    mecho "[INFO] Assumed path to Pulse Secure (PULSEPATH): $PULSEPATH"
    which pulsesvc || merror "Pulse Secure software 'pulsesvc' not found (in neither PULSEPATH nor PATH)."
    
    mecho "[INFO] Pulse Secure software: $res"
    pulsesvc --version
    
    config_home="$HOME/.pulse_secure/pulse"
    [[ -d "$config_home" ]] || merror "Pulse user-specific folder: $config_home"
    mecho "[INFO] Pulse user configuration folder: $config_home"

    confile="$config_home/.pulse_Connections.txt"
    [[ -f "$confile" ]] || merror "No Pulse GUI connection file: $confile"
    mecho "[INFO] Pulse connections file: $confile"
    # shellcheck disable=SC2207
    IFS=$'\r\n' cons=( $(grep -E "^[ \\t]*{.+}[ \\t]*$" < "$confile") )
    mecho "[INFO] Number of connections: ${#cons[@]}"
    match=false
    for ii in "${!cons[@]}"; do
	con="${cons[$ii]/^ */}"
        if echo "$con" | grep -q -F "\"$url\"" &> /dev/null; then
	    prefix=">>>"
	    match=true
	else
	    prefix="   "
	fi
        >&2 printf " %s %d. %s\\n" "$prefix" "$((ii + 1))" "${con/ *$/}"
    done
    if $match; then
        mecho "[INFO] Found connection with URL of interest: $url"
    else
        mecho "[WARN] No connection with URL of interest: $url"
    fi
    
    logfile="$config_home/pulsesvc.log"
    [[ -f "$logfile" ]] || merror "No log file: $logfile"
    
    mecho "[INFO] Log file: $logfile"
    grep -q -F Error "$logfile" &> /dev/null || { mecho "[OK] No errors found: $logfile"; exit 0; }
    
    mecho "[ERROR] Detected the following errors in the log file:"
    grep -F Error "$logfile" | >&2 tail -3
fi
