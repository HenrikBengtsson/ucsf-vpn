#! /usr/bin/env bash
###################################################################
# DON'T EDIT: This file is automatically generated from src/ files
###################################################################
### Connect to and Disconnect from the UCSF VPN
###
### Usage:
###  ucsf-vpn <command> [flags] [options]
###
### Commands:
###  start            Connect to VPN
###  stop             Disconnect from VPN
###  reconnect        Reconnect to VPN
###  restart          Disconnect and reconnect to VPN
###  toggle           Connect to or disconnect from VPN
###  status           Display VPN connection status
###  details          Display connection details in JSON format
###  routing          Display IP routing details
###  log              Display log file
###
### Options:
###  --token=<token>  One-time two-factor authentication (2FA) token or method:
###                    - 'prompt' (user is prompted to enter the token),
###                    - 'push' ("approve and confirm" in Duo app; default),
###                    - 'phone' (receive phone call and "press any key"),
###                    - 'sms' (receive code via text message),
###                    -  6 or 7 digit token (from Duo app), or
###                    -  44-letter YubiKey token ("press YubiKey")
###  --user=<user>    UCSF Active Directory ID (username)
###  --pwd=<pwd>      UCSF Active Directory ID password
###  --presudo=<lgl>  Established sudo upfront (true; default) or not (false)
###
###  --server=<host>  VPN server (default is 'remote.ucsf.edu')
###  --realm=<realm>  VPN realm (default is 'Dual-Factor Pulse Clients')
###  --url=<url>      VPN URL (default is https://{{server}}/pulse)
###  --protocol=<ptl> VPN protocol, e.g. 'nc' (default) and 'pulse'
###  --validate=<how> One or more of 'ipinfo', 'iproute', 'pid', 'ucsfit',
###                   e.g. 'pid,iproute,ucsfit' (default)
###  --theme=<theme>  Either 'cli' (default) or 'none'
###  --flavor=<flvr>  Use a customized flavor of the VPN (default: 'none')
###
### Flags:
###  --verbose        More verbose output
###  --help           Display full help
###  --version        Display version
###  --full           Display more information
###  --force          Force command
###  --args           Pass any remaining options to 'openconnect'
###
### Examples:
###  ucsf-vpn --version --full
###  ucsf-vpn start --user=alice --token=push
###  ucsf-vpn stop
###  UCSF_VPN_TOKEN=prompt ucsf-vpn start --user=alice --pwd=secrets
###  ucsf-vpn start
###  ucsf-vpn routings --full
###
### ---
###
### Environment variables:
###  UCSF_VPN_PROTOCOL     Default value for --protocol
###  UCSF_VPN_SERVER       Default value for --server
###  UCSF_VPN_TOKEN        Default value for --token
###  UCSF_VPN_THEME        Default value for --theme
###  UCSF_VPN_VALIDATE     Default value for --validate
###  UCSF_VPN_PING_SERVER  Ping server to validate internet (default: 9.9.9.9)
###  UCSF_VPN_PING_TIMEOUT Ping timeout (default: 1.0 seconds)
###  UCSF_VPN_EXTRAS       Additional arguments passed to OpenConnect
###
### User credentials:
### If user credentials (--user and --pwd) are neither specified nor given
### in ~/.netrc, then you will be prompted to enter them. To specify them
### in ~/.netrc file, use the following format:
###
###   machine remote.ucsf.edu
###       login alice
###       password secrets
###
### For security, the ~/.netrc file should be readable only by
### the user / owner of the file. If not, then 'ucsf-vpn start' will
### set its permission accordingly (by calling chmod go-rwx ~/.netrc).
###
### Requirements:
### * OpenConnect (>= 7.08) (installed: {{openconnect_version}})
### * sudo
###
### VPN Protocol:
### Different versions of OpenConnect support different VPN protocols.
### Using '--protocol=nc' (default) has been confirmed to work when using
### OpenConnect 7.08, and '--protocol=pulse' for OpenConnect 8.10.
### The 'nc' protocol specifies the old "Juniper Network Connect" protocol,
### and 'pulse' the newer "Pulse Secure" protocol.  For older version of
### OpenConnect that recognizes neither, specify '--protocol=juniper',
### which will results in using 'openconnect' legacy option '--juniper'.
###
### Troubleshooting:
### * Verify your username and password at https://remote.ucsf.edu/.
###   This should be your UCSF Active Directory ID (username); neither
###   MyAccess SFID (e.g. 'sf*****') nor UCSF email address will work.
###
### Useful resources:
### * UCSF VPN - Remote connection:
###   - https://it.ucsf.edu/service/vpn-remote-connection
### * UCSF Web-based VPN Interface:
###   - https://remote-vpn01.ucsf.edu/ (preferred)
###   - https://remote.ucsf.edu/
### * UCSF Two-Factory Authentication (2FA):
###   - https://it.ucsf.edu/services/duo-two-factor-authentication
### * UCSF Managing Your Passwords:
###   - https://it.ucsf.edu/services/managing-your-passwords
###
### Version: 6.1.0-9001
### Copyright: Henrik Bengtsson (2016-2024)
### License: GPL (>= 2.1) [https://www.gnu.org/licenses/gpl.html]
### Source: https://github.com/HenrikBengtsson/ucsf-vpn
call="$0 $*"


# -------------------------------------------------------------------------
# Output utility functions
# -------------------------------------------------------------------------
function _tput() {
    if [[ $theme == "none" ]] || [[ -n ${NO_COLOR} ]]; then
        return
    fi
    tput "$@" 2> /dev/null
}

function mecho() { echo "$@" 1>&2; }

function mdebug() {
    if ! $debug; then
        return
    fi
    {
        _tput setaf 8 ## gray
        echo "DEBUG: $*"
        _tput sgr0    ## reset
    } 1>&2
}

function merror() {
    local info version
    {
        info="ucsf-vpn $(version)"
        version=$(openconnect_version 2> /dev/null)
        if [[ -n $version ]]; then
            info="$info, OpenConnect $version"
        else
            info="$info, OpenConnect version unknown"
        fi
        [[ -n $info ]] && info=" [$info]"
        _tput setaf 1 ## red
        echo "ERROR: $*$info"
        _tput sgr0    ## reset
    } 1>&2
    _exit 1
}

function mwarn() {
    {
        _tput setaf 3 ## yellow
        echo "WARNING: $*"
        _tput sgr0    ## reset
    } 1>&2
}

function minfo() {
    if ! $verbose; then
        return
    fi
    {
        _tput setaf 4 ## blue
        echo "INFO: $*"
        _tput sgr0    ## reset
    } 1>&2
}

# shellcheck disable=SC2317
function mok() {
    {
        _tput setaf 2 ## green
        echo "OK: $*"
        _tput sgr0    ## reset
    } 1>&2
}

function mdefunct() {
    {
        _tput setaf 1 ## red
        echo "DEFUNCT: $*"
        _tput sgr0    ## reset
        exit 1
    } 1>&2
}

function mnote() {
    {
        _tput setaf 11  ## bright yellow
        echo "NOTE: $*"
        _tput sgr0    ## reset
    } 1>&2
}

function _exit() {
    local -i value

    value=${1:-0}
    pii_cleanup
    mdebug "Exiting with exit code $value"
    exit $value
}


# -------------------------------------------------------------------------
# CLI utility functions
# -------------------------------------------------------------------------
function version() {
    grep -E "^###[ ]*Version:[ ]*" "$0" | sed 's/###[ ]*Version:[ ]*//g'
}

function help() {
    local what res

    what=$1
    res=$(grep "^###" "$0" | grep -vE '^(####|### whatis: )' | cut -b 5- | sed "s/{{openconnect_version}}/$(openconnect_version)/")

    if [[ $what == "full" ]]; then
        res=$(echo "$res" | sed '/^---/d')
    else
        res=$(echo "$res" | sed '/^---/Q')
    fi

    if [[ ${UCSF_TOOLS} == "true" ]]; then
        res=$(printf "%s\\n" "${res[@]}" | sed -E 's/([^/])ucsf-vpn/\1ucsf vpn/')
    fi
    printf "%s\\n" "${res[@]}"
}


# -------------------------------------------------------------------------
# Sudo tools
# -------------------------------------------------------------------------
function assert_sudo() {
    local cmd

    cmd=$1

    if [[ -n $cmd ]]; then
        if [[ ${UCSF_TOOLS} == "true" ]]; then
            cmd=" ('ucsf vpn $cmd')"
        else
            cmd=" ('ucsf-vpn $cmd')"
        fi
    fi

    ## Should we ask for sudo permissions upfront?
    ## Note, this might add 'sudo: ... a password is required' event in
    ## /var/log/auth.log, which in turn might trigger an alert.
    if ! $presudo; then
        mwarn "If you are prompted '[sudo] password for $USER:' below, please enter the password for your account ('$USER') on your local computer ('$HOSTNAME')"
        return 0
    fi
    
    if sudo -v -n 2> /dev/null; then
        mdebug "'sudo' is already active"
        minfo "Administrative (\"sudo\") rights already establish"
        return
    fi
    mdebug "'sudo' is not active"

    {
        mwarn "This action$cmd requires administrative (\"sudo\") rights."
        _tput setaf 11  ## bright yellow
        sudo -v -p "Enter the password for your account ('$USER') on your local computer ('$HOSTNAME'): "
#        _tput setaf 15  ## bright white
        _tput sgr0      ## reset
    } 1>&2

    ## Assert success
    if ! sudo -v -n 2> /dev/null; then
        merror "Failed to establish 'sudo' access. Please check your password. It might also be that you do not have administrative rights on this machine."
    fi

    minfo "Administrative (\"sudo\") rights establish"
}


# -------------------------------------------------------------------------
# Connection, e.g. checking whether connected to the VPN or not
# -------------------------------------------------------------------------
function ucsf_it_network_info() {
    curl --silent https://help.ucsf.edu/HelpApps/ipNetVerify.php | grep -E "<td>(Connected to UCSF Network|IP Address|Network Location)</td>" | sed 's/<\/td><td>/=/' | sed -E 's/<[^>]+>//g' | sed 's/.*Connected to UCSF Network/connected/' | sed 's/.*IP Address/public_ip/' | sed 's/.*Network Location/network/' | sed 's/=No/=false/' | sed 's/=Yes/=true/' | sed -E "s/network=(.*)/network='\1'/" | sort
}

function connection_details() {
    mdebug "connection_details()"
    if [[ ! -f "$pii_file" ]]; then
        if ! is_online; then
            merror "Internet connection is not working"
        fi
        minfo "Verified that internet connection works"
        minfo "Getting public IP (from https://ipinfo.io/ip)"
        mdebug "Calling: curl --silent  --connect-timeout 3.0 https://ipinfo.io/json > \"$pii_file\""
        if ! curl --silent --connect-timeout 3.0 https://ipinfo.io/json > "$pii_file"; then
            rm "$pii_file"
        fi
        if [[ ! -f "$pii_file" ]]; then
            merror "Failed to get public IP (from https://ipinfo.io/ip)"
        fi
        mdebug "Public connection information: $(tr -d $'\n' < "$pii_file" | sed 's/  / /g')"
    fi
    cat "$pii_file"
    echo
}

function routing_details() {
    local -a ip_route info
    local ip
    local -i kk
    local use_dig=true
    local use_whois=true

    mdebug "routing_details()"
    
    if $full; then
        command -v dig &> /dev/null || use_dig=false
        mdebug "Command 'dig' available: ${use_dig}"

        command -v whois &> /dev/null || use_whois=false
        mdebug "Command 'whois' available: ${use_whois}"
        
        if ! $use_dig && ! $use_whois; then
           mwarn "Cannot annotate IP addresses (--full). Install 'dig' or 'whois' to fix this"
        fi
    else
        use_dig=false
        use_whois=false
    fi
    
    echo "Default non-VPN network interface: $(ip_route_novpn_interface)"
    mapfile -t info < <(ip route show | grep -E "\btun[[:digit:]]?\b" | cut -d ' ' -f 3 | sort -u)
    if [[ ${#info[@]} -gt 0 ]]; then
        echo "Tunnel interfaces: [n=${#info[@]}] ${info[*]}"
    else
        echo "Tunnel interfaces: none"
    fi

    echo
    echo "Nameserve configuration (/etc/resolv.conf):"
    grep -v -E "^[[:space:]]*(#|$)" /etc/resolv.conf

    mapfile -t ip_route < <(ip route show)
    echo
    echo "IP routing table (ip route show) [${#ip_route[@]} entries]:"
    for kk in "${!ip_route[@]}"; do
        row="${ip_route[${kk}]}"
        if $use_dig || $use_whois; then
            if grep -q -E "^([[:digit:].]+).*" <<< "${row}"; then
                ip=$(sed -E 's/^([[:digit:].]+).*/\1/' <<< "${row}")
                mapfile -t info < <(
                    if $use_dig; then
                        dig -x "${ip}" +short | grep -vF "/" | sed -E 's/[.]$//'
                    fi
                    if $use_whois; then
                        whois "${ip}" | grep -i -E "^(country|netname|orgname):" | sed -E 's/^([[:alpha:]]+):[[:space:]]+/\1=/I' | sort | uniq # | sed -i -E 's/^(netname|orgname):[[:space:]]+//I'
                    fi
                )
                if [[ ${#info[@]} -gt 0 ]]; then
                    row="${row}[$(printf "%s; " "${info[@]}" | sed -E 's/; $//')]"
                fi
            fi
        fi
        echo "${row}"
    done
}

function public_ip() {
    mdebug "public_ip()"
    connection_details | grep -F '"ip":' | sed -E 's/[ ",]//g' | cut -d : -f 2
}

function public_hostname() {
    mdebug "public_hostname()"
    connection_details | grep -F '"hostname":' | sed -E 's/[ ",]//g' | cut -d : -f 2
}

function public_org() {
    mdebug "public_org()"
    connection_details | grep -F '"org":' | cut -d : -f 2 | sed -E 's/(^[ ]*"|",[ ]*$)//g'
}

function public_info() {
    local ip hostname org

    mdebug "public_info()"
    ip=$(public_ip 2> /dev/null)
    if [[ -n "${ip}" ]]; then
        hostname=$(public_hostname)
        org=$(public_org)
        printf "ip=%s, hostname='%s', org='%s'" "$ip" "$hostname" "$org"
    else
        printf "<failed to infer information>"
    fi
}

function is_online() {
    local ping_server ping_servers ping_timeout

    ping_servers=${UCSF_VPN_PING_SERVER:-${1:-9.9.9.9}}
    mdebug "Ping servers: [n=${#ping_servers}]: $ping_servers"
    ping_timeout=${UCSF_VPN_PING_TIMEOUT:-1.0}
    mdebug "Ping timeout (in seconds): $ping_timeout"
    for ping_server in $ping_servers; do
      mdebug "Ping server: '$ping_server'"
      minfo "Pinging '$ping_server' once"
      if ping -c 1 -W "$ping_timeout" "$ping_server" > /dev/null 2> /dev/null; then
          return 0
      fi
    done
    return 1
}

function is_connected() {
    mdebug "is_connected()"
    ## NOTE: It appears that field 'hostname' is not always returned, e.g. when
    ## calling it multiple times in a row some calls done report that field.
    ## Because of this, we test the status on the field 'org' instead.
    connection_details | grep -q -E "org.*[:].*AS5653 University of California San Francisco"
}


function ip_route_novpn_interface() {
    mdebug "ip_route_novpn_interface()"
    ip route show | grep -E "^default " | grep -vF " tun" | cut -d ' ' -f 5
}


function wait_for_ip_route_tunnel() {
    local -i max_iter
    mdebug "Wait for tunnel to appear in IP routing table"
    max_iter=100 ## Wait for up to 10 seconds
    while ! grep -q -E 'tun[[:digit:]]' <<< "$(ip route show)"; do
        max_iter=$((max_iter - 1))
        if [[ ${max_iter} -eq 0 ]]; then
            merror "The VPN tunnel never appeared in the IP routing table:$(echo; ip route show; echo)"
        fi
        sleep 0.1
    done
}

function wait_for_ip_route() {
    local prev curr
    
    mdebug "Wait for IP routing table to stabilize"
    prev=$(ip route show)
    curr=""
    while [[ "${curr}" != "${prev}" ]]; do
        sleep 0.5
        prev="${curr}"
        curr=$(ip route show)
    done
}


# -------------------------------------------------------------------------
# Credentials, e.g. .netrc, prompting for password, etc.
# -------------------------------------------------------------------------
function source_netrc() {
    local rcfile pattern found bfr home

    if [[ -z ${NETRC} ]]; then
        if [[ ${EUID} -eq 0 ]]; then
            ## Identify the HOME folder of the logged in user, even when
            ## 'ucsf-vpn' is called via sudo
            home=$(getent passwd "$(logname)" | cut -d ":" -f 6)
            ## Fall back to HOME, if the above failed
            if [[ ! -d "${home}" ]]; then
                home=${HOME}
            fi
        else
            home=${HOME}
        fi
        rcfile=${home}/.netrc
    else
        rcfile=${NETRC}
    fi

    ## No such file?
    if [[ ! -f "${rcfile}" ]]; then
        mdebug "No .netrc file: $rcfile"
        return
    fi
    mdebug "Detected .netrc file: $rcfile"

    ## Nothing to do?
    if [[ -n "$user" && -n "$pwd" ]]; then
        mdebug "Both 'user' and 'pwd' already set. Skipping .netrc file"
        return
    fi
    
    ## Force file to be accessible only by user
    chmod go-rwx "${rcfile}"

    mdebug "- search: ${netrc_machines[*]}"
    found=false
    for machine in "${netrc_machines[@]}"; do
        pattern="^[ \\t]*machine[ \\t]+${machine}([ \\t]+|$)"
        mdebug "- search pattern: ${pattern}"

        ## No such machine?
        grep -q -E "${pattern}" "${rcfile}"

        # shellcheck disable=SC2181
        if [[ $? -eq 0 ]]; then
            mdebug "- found: ${machine}"
            found=true
            break
        fi
    done

    if ! $found; then
        mdebug "- no such machine: $machine"
        return 0
    fi

    bfr=$(awk "/${pattern}/{print; flag=1; next}/machine[ \\t]/{flag=0} flag;" "${rcfile}")
    [[ -z $bfr ]] && merror "Internal error - failed to extract ${server} credentials from ${rcfile} searching for ${netrc_machines}"

    if [[ -z "$user" ]]; then
        user=$(echo "${bfr}" | grep -F "login" | sed -E 's/.*login[[:space:]]+([^[:space:]]+).*/\1/g')
    fi
    
    if [[ -z "$pwd" ]]; then
        pwd=$(echo "${bfr}" | grep -F "password" | sed -E 's/.*password[[:space:]]+([^[:space:]]+).*/\1/g')
    fi

    mdebug "- user=${user}"
    if [[ -z "${pwd}" ]]; then
        mdebug "- pwd=<missing>"
    else
        mdebug "- pwd=<hidden>"
     fi
}

function prompt_user() {
    user=$1
    if [[ -n "${user}" ]]; then return; fi
    mdebug "PROMPT: Asking user to enter username:"
    while [ -z "${user}" ]; do
        {
            _tput setaf 11  ## bright yellow
            printf "Enter your UCSF Active Directory username: "
            _tput setaf 15  ## bright white
            read -r user
            _tput sgr0      ## reset
        } 1>&2
        user=${user/ /}
    done
    mdebug "- user=${user}"
}

function prompt_pwd() {
    pwd=$1
    if [[ -n "${pwd}" ]]; then return; fi
    mdebug "PROMPT: Asking user to enter password:"
    while [ -z "${pwd}" ]; do
        {
            _tput setaf 11  ## bright yellow
            printf "Enter your UCSF Active Directory password: "
            _tput setaf 15  ## bright white
            read -r -s pwd
            _tput sgr0      ## reset
        } 1>&2
        pwd=${pwd/ /}
    done
    mecho "<password>"

    if [[ -z "${pwd}" ]]; then
        mdebug "- pwd=<missing>"
    else
        mdebug "- pwd=<hidden>"
    fi
}

function type_of_token() {
    local token

    token=$1

    ## Hardcoded methods
    if [[ ${token} =~ ^phone[1-9]*$ ]]; then
        ## Tested with 'phone' and 'phone2', but for some reason
        ## the same phone number is called although I've got two
        ## different registered.  Also 'phone1' and 'phone3' gives
        ## an error.
        mdebug "Will authenticate via a call to a registered phone number"
        echo "phone call"
        return
    elif [[ ${token} == "push" ]]; then
        mdebug "Will authenticate via push (approve and confirm in Duo app)"
        echo "push"
        return
    elif [[ ${token} =~ ^(sms|text)[1-9]*$ ]]; then
        mdebug "Will send token via SMS"
        echo "SMS token"
        return
    elif [[ ${token} == "false" ]]; then
        mdebug "Will not use token (in the form)"
        echo "none"
        return
    fi

    ## YubiKey token (44 lower-case letters)
    if [[ ${#token} -eq 44 ]] && [[ ${token} =~ ^[a-z]+$ ]]; then
        mdebug "YubiKey token detected"
        echo "YubiKey token"
        return
    fi

    ## Digital token
    if [[ ${token} =~ ^[0-9]+$ ]]; then
        if [[ ${#token} -eq 6 ]]; then
            mdebug "Six-digit token detected"
            echo "six-digit token"
            return
        elif [[ ${#token} -eq 7 ]]; then
            mdebug "Seven-digit token detected"
            echo "seven-digit token"
            return
        fi
    fi

    echo "unknown"
}

function prompt_token() {
    local type

    token=$1
    if [[ ${token} == "prompt" || ${token} == "true" ]]; then token=; fi
    if [[ -n "${token}" ]]; then return; fi

    mdebug "PROMPT: Asking user to enter one-time token:"
    type="unknown token"
    while [ -z "${token}" ]; do
        {
            _tput setaf 11  ## bright yellow
            printf "Enter 'push' (default), 'phone', 'sms', a 6 or 7 digit token, or press your YubiKey: "
            _tput setaf 15  ## bright white
            read -r -s token
            _tput sgr0      ## reset
            ## Default?
            if [[ -z $token ]]; then
                token="push"
            fi
        } 1>&2
        token=${token/ /}
        type=$(type_of_token "$token")
        if [[ $type == "unknown token" ]]; then
            {
                _tput setaf 1 ## red
                printf "\\nERROR: Not a valid token ('push', 'phone', 'sms', 6 or 7 digits, or 44-letter YubiKey sequence)\\n"
                _tput sgr0      ## reset
            } 1>&2
            token=
        fi
    done
    mecho "<$type>"

    if [[ -z "${token}" ]]; then
        mdebug "- token=<missing>"
    else
        mdebug "- token=<hidden>"
    fi
}


# -------------------------------------------------------------------------
# OpenConnect
# -------------------------------------------------------------------------
function openconnect_version() {
    local res

    res=$(openconnect --version 2> /dev/null)
    # shellcheck disable=SC2181
    if [[ $? -ne 0 ]]; then
        echo "<PLEASE INSTALL>"
    else
        printf "%s\\n" "${res[@]}" | grep -F "version" | sed -E 's/.*v//'
    fi
}

function find_vpnc-script() {
    local file
    file=$(openconnect --help | grep -E "vpnc-script" | sed 's/[^"]*"//' | sed 's/".*//')
    if [[ -z "${file}" ]]; then
        merror "Failed to locate the default 'vpnc-script' script. It appears that openconnect --help does not specify it"
    fi
    echo "${file}"
}

function find_hooks_dir() {
    local file dir
    find_vpnc-script > /dev/null
    file=$(find_vpnc-script)
    dir=$(grep -E "^HOOKS_DIR=" "${file}" | sed 's/[^=]*=//' | sed 's/[[:blank:]]$//')
    echo "${dir}"
}


function install_vpnc() {
    local action file filename dest hooks_dir dir path
    action=${1:-install}

    mdebug "install_vpnc() ..."
    mdebug " - action: ${action}"

    ## Locate hooks directory
    find_vpnc-script > /dev/null
    hooks_dir=$(find_hooks_dir)
    mdebug " - hooks folder: ${hooks_dir}"

    filename="ucsf-vpn-flavors.sh"

    ## Is ucsf-vpn hook script already installed?
    dest="${hooks_dir}/${filename}"
    if [[ $action == "check" ]] && [[ ! -f "${dest}" ]]; then
        return 1
    fi
    
    if $force || [[ ! -f "${dest}" ]]; then
        file="$(mktemp -d)/${filename}"
        ucsf-vpn-flavors_code > "${file}"
        mdebug " - template: ${file}"
        assert_sudo "install-vpnc"

        ## Create hooks folder, if missing
        if [[ ! -d "${hooks_dir}" ]]; then
            sudo mkdir -p "${hooks_dir}"
            [[ -d "${hooks_dir}" ]] || merror "Failed to create directory: ${hooks_dir}"
        fi
    
        sudo cp "${file}" "${dest}"
        sudo chmod ugo+r "${dest}"
        [[ -f "${dest}" ]] || merror "Failed to create file: ${dest}"
        mok "Generic hook script added: ${dest}"
        if [[ -f "${file}" ]]; then
           rm "${file}"
        fi
    else
        minfo "Generic hook script already exists: ${dest}"
    fi

    ## Install symbolic links to ucsf-vpn hook script, if missing
    for dir in pre-init connect post-connect disconnect post-disconnect attempt-reconnect post-attempt-reconnect reconnect; do
        path=${hooks_dir}/${dir}.d
        dest="${path}/${filename}"
        if [[ $action == "check" ]] && [[ ! -L "${dest}" ]]; then
            return 1
        fi
        if $force || [[ ! -L "${dest}" ]]; then
            assert_sudo "install-vpnc"
            sudo mkdir -p "${path}"
            [[ -d "${path}" ]] || merror "Failed to create directory: ${path}"
            sudo ln -fs "${hooks_dir}/${filename}" "${dest}"
            [[ -L "${dest}" ]] || merror "Failed to create symbol link: ${dest} -> ${hooks_dir}/${filename}"
            mok "Symbolic link added: ${dest} -> ${hooks_dir}/${filename}"
        else
            minfo "Symbolic link already exists: ${dest} -> ${hooks_dir}/${filename}"
        fi
    done

    mdebug "install_vpnc() ... done"
    
    return 0
}

function openconnect_pid() {
    local -i pid

    ## Is there a PID file?
    if [[ ! -f "$pid_file" ]]; then
        mdebug "PID file does not exists: $pid_file"
        echo "-1"
        return
    fi

    mdebug "PID file exists: $pid_file"
    pid=$(cat "$pid_file")
    mdebug "PID recorded in file: $pid"

    ## Is the process still running?
    if ps -p $pid > /dev/null; then
        mdebug "Process is running: $pid"
        echo $pid
        return
    fi

    ## Remove stray PID file
    rm "$pid_file"
    mwarn "Removed stray PID file with non-existing process (PID=$pid): $pid_file"
    echo -1
}

function openconnect_flavor() {
    local res
    
    ## Is there a PID file?
    if [[ ! -f "${flavor_file}" ]]; then
        mwarn "Flavor file does not exists: ${flavor_file}"
        echo "<unknown>"
        return
    fi
    mdebug "Flavor file exists: ${flavor_file}"
    res=$(cat "${flavor_file}")
    if [[ -z ${res} ]]; then
        res="none"
    fi
    echo "${res}"
}


function prompt_yesno() {
    local prompt answer
    
    prompt=${1:?}

    mdebug "PROMPT: Asking user for yes-no input:"
    while true; do
        {
            _tput setaf 11  ## bright yellow
            printf "%s [Y/n]: " "${prompt}"
            _tput setaf 15  ## bright white
            read -r answer
            _tput sgr0      ## reset
        } 1>&2
        
        ## Default?
        if [[ ${answer} == "" ]]; then
            return 0
        fi

        ## yes or no?
        answer=${answer/ /}
        answer=$(tr '[:upper:]' '[:lower:]' <<< "${answer}")
        mdebug "- answer=${answer}"
        if [[ ${answer} == "yes" ]] || [[ ${answer} == "y" ]]; then
            return 0
        elif [[ ${answer} == "no" ]] || [[ ${answer} == "n" ]]; then
            return 1
        fi                 
    done
}


function openconnect_start() {
    local two_pwds openconnect_log_file log_file main_reason reason post_reason
    local -a opts
    local -i pid

    mdebug "openconnect_start() ..."

    pid=$(openconnect_pid)
    if [[ $pid != -1 ]]; then
        if [[ ! $force ]]; then
            merror "A VPN process ('openconnect' PID $pid) is already running."
        fi
    fi

    if ! $force; then
        if [[ $validate == *pid* ]] && [[ $(openconnect_pid) != -1 ]]; then
           mwarn "Skipping - already connected to the VPN"
           return
        elif [[ $validate == *ipinfo* ]] && is_connected; then
           mwarn "Skipping - already connected to the VPN"
           return
        fi
    fi

    ## Assert that OpenConnect is not already running
    if [[ -f "$pid_file" ]]; then
        merror "Hmm, this might be a bug. Do you already have an active VPN connection? (Detected PID file '$pid_file'; if incorrect, remove with 'sudo rm $pid_file')"
    fi

    if ! is_online; then
        merror "Internet connection is not working"
    fi

    minfo "Preparing to connect to VPN server '$server'"

    if [[ ${flavor} != "none" ]]; then
        ## Are vpnc generic hook scripts installed?
        if ! install_vpnc "check"; then
            if prompt_yesno "Do you want to install required ucsf-vpn hook scripts?"; then
                install_vpnc "install"
            else
                merror "Generic ucsf-vpn hook scripts not installed. To install manually, call 'ucsf vpn install-vpnc'"
            fi
        fi
        ## Assert that --flavor=<flavor> exists, if specified
        flavor_home > /dev/null
    fi
    
    assert_sudo "start"

    ## Load user credentials from file?
    source_netrc

    ## Prompt for username and password, if missing
    prompt_user "${user}"
    prompt_pwd "${pwd}"

    ## Prompt for 2FA token?
    if [[ "$realm" == "Dual-Factor Pulse Clients" ]]; then
        ## Prompt for one-time token, if requested
        prompt_token "${token}"
    fi

    ## openconnect options
    opts=()
    opts+=("${extras[@]}")

    ## VPN protocol
    if [[ "$protocol" == "juniper" ]]; then
        opts+=("--juniper" "${url}")
    else
        opts+=("--protocol=${protocol}" "${url}")
    fi
    
    opts+=("--background")

    if [[ -n $user ]]; then
        opts+=("--user=$user")
    fi
    if [[ -n $pwd ]]; then
        opts+=("--passwd-on-stdin")
    fi

    opts+=("--pid-file=$pid_file")

    if ! $debug; then
        opts+=("--quiet")
    fi

    mdebug "call: $call"
    mdebug "user: $user"
    if [[ -n $pwd ]]; then
        mdebug "pwd: <hidden>"
    else
        mdebug "pwd: <not specified>"
    fi
    if [[ -n $token ]]; then
        if [[ $token == "prompt" ]]; then
            mdebug "token: <prompt>"
        elif [[ $token == "push" || $token =~ ^(phone|sms|text)[1-9]*$ ]]; then
            mdebug "token: $token"
        else
            mdebug "token: <hidden>"
        fi
    else
        mdebug "token: <not specified>"
    fi
    mdebug "opts: [n=${#opts[@]}] ${opts[*]}"
    mdebug "call: sudo UCSF_VPN_VERSION=$(version) UCSF_VPN_FLAVOR=$(flavor_home) UCSF_VPN_LOGFILE=$(logfile) openconnect ${opts[*]} --authgroup=\"$realm\""

    if [[ $token == "push" ]]; then
         mnote "Open the Duo Mobile app on your smartphone or tablet to confirm ..."
    elif [[ $token =~ ^phone[1-9]*$ ]]; then
         mnote "Be prepared to answer your phone to confirm ..."
    elif [[ $token =~ ^(sms|text)[1-9]*$ ]]; then
         merror "Sending tokens via SMS is not supported by the OpenConnect interface"
    fi

    minfo "Connecting to VPN server '${server}'"

    if $dryrun; then
        _exit 0
    fi

    log_file="$(logfile)"
    openconnect_log_file="$(openconnect_logfile)"
    rm "${log_file}"
    log "openconnect_start() ..."
    
    ## Record IP routing table before connecting to the VPN
    ip route show > "${ip_route_novpn_file}"

    ## Record hostname resolve file before connecting to the VPN
    cat /etc/resolv.conf > "${resolv_novpn_file}"
    
    log "ip route show:"
    ip route show >> "${log_file}"

    if [[ -n $pwd && -n $token ]]; then
        case "${UCSF_VPN_TWO_PWDS:-password-token}" in
            "password-token")
                two_pwds="$pwd\n$token\n"
                ;;
            "token-password")
                two_pwds="$token\n$pwd\n"
                ;;
            *)
                merror "Unknown value of UCSF_VPN_TWO_PWDS: '$UCSF_VPN_TWO_PWDS'"
                ;;
        esac
        # shellcheck disable=SC2086
        sudo echo -e "$two_pwds" | sudo UCSF_VPN_VERSION="$(version)" UCSF_VPN_FLAVOR="$(flavor_home)" UCSF_VPN_LOGFILE="$(logfile)" openconnect "${opts[@]}" --authgroup="$realm" 2> "${openconnect_log_file}" 1> "${openconnect_log_file}"
    else
        # shellcheck disable=SC2086
        sudo UCSF_VPN_VERSION="$(version)" UCSF_VPN_FLAVOR="$(flavor_home)" UCSF_VPN_LOGFILE="$(logfile)" openconnect "${opts[@]}" --authgroup="$realm" 2> "${openconnect_log_file}" 1> "${openconnect_log_file}"
    fi

    ## Update IP-info file
    pii_file=$(make_pii_file)

    pid=$(openconnect_pid)
    mdebug "pid=$pid"
    if [[ $pid == -1 ]]; then
        cat "${openconnect_log_file}"

        ## Report on ping for VPN server
        if ! is_online "$server"; then
            main_reason="Most likely reason: The VPN server ($server) does not respond to ping; check your internet connection."
        else
            post_reason="Miscellaneous: The VPN server ($server) responds to ping"
        fi

        ## Post-mortem analysis of the standard error.
        ## (a) When the wrong username or password is entered, we will get:
        ##       username:password:
        ##       fgets (stdin): Inappropriate ioctl for device
        ## (b) When the username and password is correct but the wrong token
        ##     is provided, or user declines, we will get:
        ##       password#2:
        ##       username:fgets (stdin): Resource temporarily unavailable

        ## Was the wrong credentials given?
        if grep -q -F "username:password" "${openconnect_log_file}"; then
            reason="Incorrect username or password"
            reason="${reason}. You can test your credentials via the Web VPN at https://${UCSF_WEB_VPN_SERVER:-remote-vpn01.ucsf.edu}/"
        elif grep -q -F "Inappropriate ioctl for device" "${openconnect_log_file}"; then
            reason="Incorrect username or password"
            reason="${reason}. You can test your credentials via the Web VPN at https://${UCSF_WEB_VPN_SERVER:-remote-vpn01.ucsf.edu}/"
        elif grep -q -E "password#2" "${openconnect_log_file}"; then
            reason="2FA token not accepted"
        elif grep -q -iF "Unknown VPN protocol" "${openconnect_log_file}"; then
            reason="Unknown VPN protocol (option --protocol=<ptl>)"
        else
            reason="Check your username, password, and token"
            reason="${reason}. You can test your credentials via the Web VPN at https://${UCSF_WEB_VPN_SERVER:-remote-vpn01.ucsf.edu}/"
        fi
        
        if [[ -n "${main_reason}" ]]; then
            reason="${main_reason} Possible other reason: ${reason}"
        else
            reason="Likely reason: ${reason}"
        fi
        reason="Failed to connect to VPN server. ${reason}"
        if [[ -n "${post_reason}" ]]; then
            reason="${reason}. ${post_reason}"
        fi
        merror "${reason}"
    fi

    ## Wait for VPN tunnel to appear in IP routing table
    wait_for_ip_route_tunnel
    
    ## Wait for IP routing table to stabilize
    wait_for_ip_route

    ## Record IP routing table after having connected to the VPN
    ip route show > "${ip_route_vpn_file}"

    ## Record hostname resolve file after having connected to the VPN
    cat /etc/resolv.conf > "${resolv_vpn_file}"

    default_route_after=$(grep -E '^default[[:space:]].*tun' "${ip_route_vpn_file}" | sed 's/default //' | sed -E 's/ +$//')
    mdebug "Default IP routing changed to: ${default_route_after}"
    
    if $debug; then
        mdebug "Changes made to the IP routing table (ip route show):"
        {
            _tput setaf 8 ## gray
            diff -u -w "${ip_route_novpn_file}" "${ip_route_vpn_file}"
            _tput sgr0    ## reset
        } 1>&2

        mdebug "Changes made to /etc/resolv.conf:"
        {
            _tput setaf 8 ## gray
            diff -u -w "${resolv_novpn_file}" "${resolv_vpn_file}"
            _tput sgr0    ## reset
        } 1>&2
    fi

    if $verbose; then
      default_route_before=$(grep -E '^default[[:space:]]' "${ip_route_novpn_file}" | sed 's/default //' | sed -E 's/ +$//')
      minfo "Default IP routing was changed from '${default_route_before}' to '${default_route_after}'"
    fi

    log "record flavor"
    # shellcheck disable=SC2005
    echo "$(flavor_home)" > "${flavor_file}"

    log "openconnect_start() ... done"
    
    minfo "Connected to VPN server"
}

function openconnect_stop() {
    local kill_timeout
    local -i kk pid

    mdebug "openconnect_stop() ..."

    log "openconnect_stop() ..."
    
    pid=$(openconnect_pid)
    if [[ $pid == -1 ]]; then
        mwarn "Could not detect a VPN ('openconnect') process. Skipping."
        return
#        merror "Failed to located a VPN ('openconnect') process. Are you really connected by VPN? If so, you could manually kill *all* OpenConnect processes by calling 'sudo pkill -INT openconnect'. CAREFUL!"
    fi

    minfo "Disconnecting from VPN server"

    assert_sudo "stop"

    ## Record IP routing table while still connected to the VPN
    ip route show > "${ip_route_vpn_file}"

    ## Record hostname resolve file while still connected to the VPN
    cat /etc/resolv.conf > "${resolv_vpn_file}"
    
    ## Signal SIGINT to terminate OpenConnect. If the first one fails,
    ## try another one
    # shellcheck disable=SC2034
    for kk in {1..2}; do
        ## From 'man openconnect': SIGINT performs a clean shutdown by logging the
        ## session off, disconnecting from the gateway, and running the vpnc-script
        ## to restore the network configuration.
        mdebug "Killing OpenConnect process: sudo kill -s INT \"$pid\" 2> /dev/null"
        log "- sudo kill -s INT $pid"
        sudo kill -s INT $pid 2> /dev/null
    
         ## Wait for process to terminate
        kill_timeout=10
        timeout "$kill_timeout" tail --pid=$pid -f /dev/null
    
        ## Was the process terminated?
        if ! ps -p $pid > /dev/null; then
            break
        fi
    done

    ## Update IP-info file
    pii_file=$(make_pii_file)

    ## Assert that the process was terminated
    if ps -p $pid > /dev/null; then
        merror "Failed to terminate VPN process ('openconnect' with PID $pid). You could manually kill *all* OpenConnect processes by calling 'sudo pkill -INT openconnect'. CAREFUL!"
    fi

    ## OpenConnect should remove PID file when terminated properly,
    ## but if not, let us remove it here
    if [[ -f "$pid_file" ]]; then
        rm -f "$pid_file"
        mwarn "OpenConnect PID file removed manually: $pid_file"
    fi

    ## Wait for IP routing table to stabilize
    wait_for_ip_route
    
    ## Record IP routing table after being disconnected from the VPN
    ip route show > "${ip_route_novpn_file}"

    ## Record hostname resolve file after being disconnected from the VPN
    cat /etc/resolv.conf > "${resolv_novpn_file}"
    
    default_route_after=$(grep -E '^default[[:space:]]' "${ip_route_novpn_file}" | sed 's/default //' | sed -E 's/ +$//')
    mdebug "Default IP routing changed to: ${default_route_after}"

    
    if $debug; then
        mdebug "Changes made to the IP routing table (ip route show):"
        {
            _tput setaf 8 ## gray
            diff -u -w "${ip_route_vpn_file}" "${ip_route_novpn_file}"
            _tput sgr0    ## reset
        } 1>&2

        mdebug "Changes made to /etc/resolv.conf:"
        {
            _tput setaf 8 ## gray
            diff -u -w "${resolv_vpn_file}" "${resolv_novpn_file}"
            _tput sgr0    ## reset
        } 1>&2
    fi
    
    if $verbose; then
      default_route_before=$(grep -E '^default[[:space:]].*tun' "${ip_route_vpn_file}" | sed 's/default //' | sed -E 's/ +$//')
      minfo "Default IP routing was changed from '${default_route_before}' to '${default_route_after}'"
    fi

    log "openconnect_stop() ... done"

    minfo "Disconnected from VPN server"
}


function openconnect_reconnect() {
    local kill_timeout
    local -i kk pid

    mdebug "openconnect_reconnect() ..."

    log "openconnect_reconnect() ..."
    
    pid=$(openconnect_pid)
    if [[ $pid == -1 ]]; then
        mwarn "Could not detect a VPN ('openconnect') process. Skipping."
        return
    fi

    minfo "Reconnecting to VPN server"

    assert_sudo "stop"

    ## From 'man openconnect': SIGUSR2 forces an immediate disconnection and
    ## reconnection; this can be used to quickly recover from LAN IP address
    ## changes.
    mdebug "sudo kill -s USR2 $pid"
    log "- sudo kill -s USR2 $pid"
    sudo kill -s USR2 $pid 2> /dev/null

    status "connected"

    log "openconnect_reconnect() ... done"

    minfo "Reconnected to VPN server"
}



function status() {
    local assert mcmd msg ok
    local -i pid
    local -a info
    local -a msgs
    local -a methods
    local -a connected
    local method
    local oldIFS
    local timestamp now since s m h age

    assert=$1
    mdebug "status() ..."
    mdebug "- assert='$assert'"
    mdebug "- validate='$validate'"
    minfo "validate='$validate'"

    oldIFS="$IFS"
    IFS=","
    read -ra methods <<< "$validate"
    IFS="$oldIFS"
    mdebug "- methods: [n=${#methods[@]}] ${methods[*]}"

    connected=()
    for method in "${methods[@]}"; do
        mdebug "Checking with ${method} ..."
        if [[ $method == pid ]]; then
            pid=$(openconnect_pid)
            if [[ $pid == -1 ]]; then
                connected+=(false)
                msg="No 'openconnect' process running"
            else
                connected+=(true)
                timestamp=$(ps -p "${pid}" -o lstart=)
                if [[ -n ${timestamp} ]]; then
                    timestamp=$(date -d "${timestamp}" --iso-8601=seconds)
                    since=$(date -d "${timestamp}" +%s)
                    now=$(date +%s)
		    s=$((now - since))
		    m=$((s / 60))
		    s=$((s - 60 * m))
		    h=$((m / 60))
		    m=$((m - 60 * h))
		    age=$(printf "%02dh%02dm%02ds" "${h}" "${m}"  "${s}")
                fi
                msg="'openconnect' process running (started ${age} ago on ${timestamp}; PID=${pid})"
            fi
            msgs+=("OpenConnect status: $msg")
        elif [[ $method == iproute ]]; then
            mapfile -t info < <(ip route show | grep -E "\btun[[:digit:]]?\b" | cut -d ' ' -f 3 | sort -u)
            if [[ ${#info[@]} -gt 0 ]]; then
                connected+=(true)
                msg="yes (n=${#info[@]} ${info[*]})"
            else
                connected+=(false)
                msg="none"
            fi
            msgs+=("IP routing tunnels: ${msg}")
        elif [[ $method == ucsfit ]]; then
            mapfile -t info < <(ucsf_it_network_info)
            if grep -q "connected=true" <<< "${info[0]}"; then
                connected+=(true)
                msg="yes (n=${#info[@]} ${info[*]})"
            else
                connected+=(false)
                msg="no (n=${#info[@]} ${info[*]})"
            fi
            msgs+=("Public IP information (UCSF IT): ${info[2]}, ${info[1]}")
        elif [[ $method == ipinfo ]]; then
            if is_connected; then
                connected+=(true)
            else
                connected+=(false)
            fi
            msgs+=("Public IP information (ipinfo.io): $(public_info)")
        else
            merror "Unknown --validate value: $method"
        fi
        mdebug "- connected: [n=${#connected[@]}] ${connected[*]}"
        mdebug "- msgs: [n=${#msgs[@]}] ${msgs[*]}"
        mdebug "Checking with ${method} ... done"
    done

    ## Consensus
    mapfile -t connected < <(printf "%s\n" "${connected[@]}" | sort -u)
    mdebug "- connected: [n=${#connected[@]}] ${connected[*]}"

    if [[ ${#connected[@]} -eq 1 ]]; then
        mcmd="echo"
        if [[ -n $assert ]]; then
            ok=true
            if [[ $assert == "disconnected" ]] && ${connected[0]}; then
                ok=false
            elif [[ $assert == "connected" ]] && ! ${connected[0]}; then
                ok=false
            fi
            if $ok; then
                mcmd="mok"
            else
                mcmd="merror"
            fi
        fi
        for msg in "${msgs[@]}"; do
            "$mcmd" "${msg}"
        done
        if ${connected[0]}; then
            msg="$(openconnect_flavor)"
            if [[ ${msg} != "none" ]]; then
                msg="${flavor} (${msg})"
            fi
            "$mcmd" "Flavor: ${msg}"
            msg="Connected to the VPN"
        else
            msg="Not connected to the VPN"
        fi
        "$mcmd" "$msg"
    else
        for msg in "${msgs[@]}"; do
            echo "${msg}"
        done
        merror "Conflicting results whether connected to the VPN. This can happen if the network dropped temporarily while on the VPN. You might be able to fix it with 'ucsf vpn restart'"
    fi

    mdebug "status() ... done"
}


# -------------------------------------------------------------------------
# XDG config utility functions
# -------------------------------------------------------------------------
function xdg_state_path() {
    local path

    path=${XDG_STATE_HOME:-$HOME/.local/state}/ucsf-vpn
    if [ ! -d "$path" ]; then
        mkdir -p "$path"
    fi
    echo "$path"
}

function xdg_config_path() {
    local path

    ## https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
    path=${XDG_CONFIG_HOME:-$HOME/.config}/ucsf-vpn
    if [ ! -d "$path" ]; then
        mkdir -p "$path"
    fi
    echo "$path"
}

function make_pii_file() {
    pii_cleanup
    mktemp --dry-run --tmpdir="$(xdg_state_path)" --suffix=-ipinfo.json
}

function pii_cleanup() {
    if [[ -f "$pii_file" ]]; then
         mdebug "Removing file: $pii_file"
        rm "$pii_file"
    fi
}


# Function to safely parse and set environment variables for file
function source_envs() {
    local file line key value
    
    file="$(xdg_config_path)/envs"

    ## Nothing to do?
    if [[ ! -f "${file}" ]]; then
        return 0
    fi

    while IFS= read -r line; do
        # Skip empty lines and lines starting with #
        [[ -z "$line" ]] && continue
        [[ "$line" =~ ^[[:blank:]]*# ]] && continue

        # Assert that line specifies a key=value pair
        if [[ ! "$line" =~ ^[a-zA-Z_][a-zA-Z0-9_]*=.*$ ]]; then
            merror "Syntax error in ${file}: ${line}"
        fi

        # Split the line into key and value parts
        key="${line%%=*}"
        value="${line#*=}"

        # Resolve any variables and expressions in the value part
        eval "value=${value}"

        # Assign the resolved value to environment variable specified by the key
        export "$key=$value"
    done < "${file}"
}


function flavor_home() {
    local path hook pathname
    local -i count

    ## No flavor specified
    if [[ ${flavor} == "none" ]]; then
        echo
        return
    fi

    path="$(xdg_config_path)/flavors/${flavor}"
    if [[ ! -d "${path}" ]]; then
        merror "Folder not found: ${path}"
    fi

    count=0
    for hook in pre-init connect post-connect disconnect post-disconnect attempt-reconnect post-attempt-reconnect reconnect; do
        pathname=${path}/${hook}.sh
        if [[ -f "${pathname}" ]]; then
            if ! bash -n "${pathname}"; then
                merror "File syntax error: ${pathname}"
            fi
            count+=1
        fi
    done

    if [[ "${count}" -eq 0 ]]; then
        merror "Flavor folder contains no known hook script files: ${path}"
    fi

    echo "${path}"    
}    


## Note, this function needs to be in src/ucsf-vpn.sh in order for 'make build' to work
function ucsf-vpn-flavors_code() {
cat << HOOK_SCRIPT_EOF
#!/bin/sh
####################################################################
# Use user-specific UCSF VPN configurations
#
# Install:
#   ucsf vpn install-vpnc
#
# Requires:
#   https://github.com/HenrikBengtsson/ucsf-vpn
####################################################################

## Called via 'ucsf-vpn'?
if [ -n "\${UCSF_VPN_VERSION}" ]; then
    ucsf_vpn_log() {
       echo "[\$(date --iso-8601=seconds)] \$*" >> "\${UCSF_VPN_LOGFILE}"
    }

    ucsf_vpn_log "\$* ..."
    ucsf_vpn_log "UCSF_VPN_VERSION=\${UCSF_VPN_VERSION}"
    ucsf_vpn_log "UCSF_VPN_FLAVOR=\${UCSF_VPN_FLAVOR}"

    _hook_="\$1"
    ucsf_vpn_log "hook=\${_hook_}"

    _hook_file_="\${UCSF_VPN_FLAVOR}/\${_hook_}.sh"
    ucsf_vpn_log "\${_hook_file_} ..."
    if [ -f "\${_hook_file_}" ]; then
        _hook_status_="done"

        # shellcheck disable=SC1090
        . "\${_hook_file_}" || _hook_status_="error"
        
        ucsf_vpn_log "\${_hook_file_} ... \${_hook_status_}"
    else
        ucsf_vpn_log "\${_hook_file_} ... non-existing"
    fi
    
    ucsf_vpn_log "\$* ... done"
fi
HOOK_SCRIPT_EOF
}


function openconnect_logfile() {
    local path file
    
    path="$(xdg_state_path)/logs"
    if [ ! -d "$path" ]; then
        mkdir -p "$path"
    fi

    file="${path}"/openconnect.log

    ## Create log file
    touch "${file}"
    
    echo "${file}"
}

function logfile() {
    local path file
    
    path="$(xdg_state_path)/logs"
    if [ ! -d "$path" ]; then
        mkdir -p "$path"
    fi

    file="${path}"/ucsf-vpn.log

    ## Create log file
    touch "${file}"
    
    echo "${file}"
}

log() {
    echo "[$(date --iso-8601=seconds)] $*" >> "$(logfile)"
}


# -------------------------------------------------------------------------
# Deprecated and defunct
# -------------------------------------------------------------------------
pulse_is_defunct() {
    merror "Support for the Pulse Secure GUI, and command-line options associated with it, are defunct as of ucsf-vpn 6.0.0 (2024-05-20) in favor of OpenConnect (--method=openconnect; default)"
}

# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
pid_file="$(xdg_state_path)/openconnect.pid"
flavor_file="$(xdg_state_path)/openconnect.flavor"
ip_route_novpn_file="$(xdg_state_path)/ip-route.novpn.out"
ip_route_vpn_file="$(xdg_state_path)/ip-route.vpn.out"
resolv_novpn_file="$(xdg_state_path)/resolv.novpn.out"
resolv_vpn_file="$(xdg_state_path)/resolv.vpn.out"
pii_file=$(make_pii_file)

source_envs


## Actions
action=

## VPN method: 'openconnect' (default)
method=${UCSF_VPN_METHOD:-openconnect}

## Options
server=${UCSF_VPN_SERVER:-remote.ucsf.edu}
url=
theme=${UCSF_VPN_THEME:-cli}
force=false
full=false
debug=false
verbose=false
validate=
dryrun=false
realm=
extras=("${UCSF_VPN_EXTRAS[@]}")
protocol=${UCSF_VPN_PROTOCOL:-nc}
presudo=${UCSF_VPN_PRESUDO:-true}
flavor=${UCSF_VPN_FLAVOR:-none}

## User credentials
user=
pwd=
token=${UCSF_VPN_TOKEN:-push}

# Parse command-line options
while [[ $# -gt 0 ]]; do
    mdebug "Next CLI argument: $1"

    ## Commands:
    if [[ "$1" == "start" ]]; then
        action=$1
    elif [[ "$1" == "stop" ]]; then
        action=$1
    elif [[ "$1" == "reconnect" ]]; then
        action=$1
    elif [[ "$1" == "toggle" ]]; then
        action=$1
        force=true
    elif [[ "$1" == "restart" ]]; then
        action=$1
        force=true
    elif [[ "$1" == "status" ]]; then
        action=$1
    elif [[ "$1" == "details" ]]; then
        action=$1
    elif [[ "$1" == "routing" ]]; then
        action=$1
    elif [[ "$1" == "install-vpnc" ]]; then
        action=$1
    elif [[ "$1" == "log" ]]; then
        action=$1
    elif [[ "$1" == "troubleshoot" ]]; then
        pulse_is_defunct
    elif [[ "$1" == "open-gui" ]]; then
        pulse_is_defunct
    elif [[ "$1" == "close-gui" ]]; then
        pulse_is_defunct

    ## Options (--flags):
    elif [[ "$1" =~ ^--[^=]*$ ]]; then
        flag=${1//--}
        if [[ "$flag" == "args" ]]; then
            # Treat all options after --args as 'extras'
            shift
            extras+=("$@")
            ## Consume all remaining options
            shift "$#"
        elif [[ "$flag" == "help" ]]; then
            action=help
        elif [[ "$flag" == "version" ]]; then
            action=version
        elif [[ "$flag" == "debug" ]]; then
            debug=true
        elif [[ "$flag" == "verbose" ]]; then
            verbose=true
        elif [[ "$flag" == "force" ]]; then
            force=true
        elif [[ "$flag" == "full" ]]; then
            full=true
        elif [[ "$flag" == "dry-run" ]]; then
            dryrun=true
        elif [[ "$flag" == "dryrun" ]]; then
            merror "Did you mean to use '--dry-run'?"
        elif [[ "$flag" == "notification" ]]; then
            pulse_is_defunct
        elif [[ "$flag" == "no-notification" ]]; then
            pulse_is_defunct
        elif [[ "$flag" == "gui" ]]; then
            pulse_is_defunct
        elif [[ "$flag" == "no-gui" ]]; then
            pulse_is_defunct
        else
            merror "Unknown option: '$1'"
        fi

    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        mdebug "Key-value option '$1' parsed to key='$key', value='$value'"
        if [[ -z $value ]]; then
            merror "Option '--$key' must not be empty"
        fi
        if [[ "$key" == "method" ]]; then
            mwarn "There is no longer a need to specify method, because the default --method=openconnect is the only support one"
            method=$value
        elif [[ "$key" == "url" ]]; then
            url=$value
        elif [[ "$key" == "server" ]]; then
            server=$value
        elif [[ "$key" == "realm" ]]; then
            realm=$value
        elif [[ "$key" == "user" ]]; then
            user=$value
        elif [[ "$key" == "protocol" ]]; then
            protocol=$value
        elif [[ "$key" == "pwd" ]]; then
            pwd=$value
        elif [[ "$key" == "token" ]]; then
            token=$value
        elif [[ "$key" == "speed" ]]; then
            pulse_is_defunct
        elif [[ "$key" == "theme" ]]; then
            theme=$value
        elif [[ "$key" == "validate" ]]; then
            validate=$value
        elif [[ "$key" == "presudo" ]]; then
            if [[ $value == "true" ]]; then
                presudo=true
            elif [[ $value == "false" ]]; then
                presudo=false
            else
                merror "Unknown value --presudo=$value"
            fi
        elif [[ "$key" == "flavor" ]]; then
            flavor=$value
        else
            merror "Unknown option: '$1'"
        fi

    ## DEPRECATED: Options (--key value):
    elif [[ "$1" == "--skip" ]]; then
        mdefunct "Command-line option '$1' is defunct."
    elif [[ "$1" =~ ^--(method|pwd|realm|server|speed|token|url|user)$ ]]; then
        mdefunct "Command-line option format '$1 $2' is defunct. Use '$1=$2' instead."
    else
        merror "Unknown option: '$1'"
    fi
    shift
done


## --help should always be available prior to any validation errors
if [[ -z $action ]]; then
    help
    _exit 0
elif [[ $action == "help" ]]; then
    help full
    _exit 0
fi


## Use default URL?
[[ -z "$url" ]] && url=https://${server}/pulse


# -------------------------------------------------------------------------
# Validate options
# -------------------------------------------------------------------------
## Validate 'method'
if [[ ${method} == "openconnect" ]]; then
    mdebug "Method: $method"
elif [[ ${method} == "pulse" ]]; then
    pulse_is_defunct
else
    merror "Unknown value on option --method: '$method'"
fi

## Validate 'realm'
if [[ -z $realm ]]; then
    realm="Dual-Factor Pulse Clients"
fi
if [[ $realm == "Single-Factor Pulse Clients" ]]; then
    true
elif [[ $realm == "Dual-Factor Pulse Clients" ]]; then
    true
elif [[ $realm == "single" ]]; then
    realm="Single-Factor Pulse Clients"
elif [[ $realm == "dual" ]]; then
    realm="Dual-Factor Pulse Clients"
else
    merror "Unknown value on option --realm: '$realm'"
fi

## Validate 'token':
if [[ ${token} == "true" ]]; then  ## Backward compatibility
    token="prompt"
fi
if [[ $realm != "Dual-Factor Pulse Clients" ]]; then
    token=false
elif [[ ${token} == "prompt" || ${token} == "true" ]]; then
    mdebug "Will prompt user for 2FA token"
elif [[ ${token} == "false" ]]; then
    mdebug "Will not use 2FA authentication"
elif [[ $(type_of_token "$token") == "unknown" ]]; then
    merror "The token (--token) must be 6 or 7 digits or 44 letters (YubiKey)"
fi

## Validate 'theme'
if [[ ! $theme =~ ^(cli|none)$ ]]; then
    merror "Unknown --theme value: '$theme'"
fi

## Validate 'validate'
if [[ -z $validate ]]; then
    validate=${UCSF_VPN_VALIDATE:-pid,iproute,ucsfit}
fi



# -------------------------------------------------------------------------
# Initiate
# -------------------------------------------------------------------------
## Regular expression for locating the proper netrc entry
if [[ "$server" == "remote.ucsf.edu" ]]; then
    netrc_machines=${server}
else
    netrc_machines=("${server}" remote.ucsf.edu)
fi

mdebug "call: $call"
mdebug "action: $action"
mdebug "VPN server: $server"
mdebug "Realm: '$realm'"
mdebug "protocol: $protocol"
mdebug "user: $user"
if [[ -z "${pwd}" ]]; then
    mdebug "pwd=<missing>"
else
    mdebug "pwd=<hidden>"
fi
if [[ -z "${token}" ]]; then
    mdebug "token=<missing>"
elif [[ $token == "prompt" ]]; then
    mdebug "token=<prompt>"
elif [[ $token == "push" || $token == "sms" || $token =~ ^phone[1-9]*$ ]]; then
    mdebug "token=$token"
else
    mdebug "token=<hidden>"
fi
mdebug "verbose: $verbose"
mdebug "force: $force"
mdebug "validate: $validate"
mdebug "dryrun: $dryrun"
mdebug "extras: [n=${#extras[@]}] ${extras[*]}"
mdebug "method: $method"
mdebug "netrc_machines: ${netrc_machines[*]}"
mdebug "pid_file: $pid_file"
mdebug "openconnect_pid: $(openconnect_pid)"
mdebug "pii_file: $pii_file"


# -------------------------------------------------------------------------
# Actions
# -------------------------------------------------------------------------
if [[ $action == "version" ]]; then
    if $full; then
        echo "ucsf-vpn $(version)"
        echo "OpenConnect $(openconnect_version)"
    else
        version
    fi
    _exit 0
fi

if [[ $action == "status" ]]; then
    status
elif [[ $action == "details" ]]; then
    connection_details
    _exit $?
elif [[ $action == "routing" ]]; then
    routing_details
    _exit $?
elif [[ $action == "install-vpnc" ]]; then
    install_vpnc "install"
    _exit $?
elif [[ $action == "start" ]]; then
    openconnect_start
    res=$?
    status "connected"
elif [[ $action == "stop" ]]; then
    openconnect_stop
    status "disconnected"
elif [[ $action == "reconnect" ]]; then
    openconnect_reconnect
elif [[ $action == "restart" ]]; then
    if $force || is_connected; then
        openconnect_stop
    fi
    openconnect_start
    res=$?
    status "connected"
elif [[ $action == "toggle" ]]; then
    if ! is_connected; then
      openconnect_start
      status "connected"
    else
      openconnect_stop
      status "disconnected"
    fi
elif [[ $action == "log" ]]; then
    LOGFILE=/var/log/syslog
    minfo "Displaying 'VPN' entries in log file: $LOGFILE"
    if [[ ! -f $LOGFILE ]]; then
        mwarn "No such log file: $LOGFILE"
        _exit 1
    fi
    grep VPN "$LOGFILE"
fi

_exit 0
